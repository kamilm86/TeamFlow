import sys
import sqlite3
import os
import time
from datetime import datetime, timedelta, date
from PySide6.QtWidgets import (QApplication, QMainWindow, QTableWidget, QTableWidgetItem,
                               QVBoxLayout, QHBoxLayout, QWidget, QLabel, QComboBox,
                               QPushButton, QHeaderView, QAbstractItemView, QListWidget,
                               QListWidgetItem, QLineEdit, QDialog, QCheckBox, QFrame, QDateEdit,
                               QFormLayout, QDialogButtonBox, QMessageBox, QSplitter)
from PySide6.QtCore import Qt, QThread, Signal, QDate, QTimer
from PySide6.QtGui import QFont, QColor

from config import DATABASE_CONFIG, ENVIRONMENT
from db_connector import DatabaseConnector
from theme_dialog import ThemeSettingsDialog, InsertSymbolDialog
from settings_db import SettingsDatabase


class DataFetcherThread(QThread):
    data_fetched = Signal(list)  # Sygnał z danymi grafiku i danymi zdarzeń

    def __init__(self, year, month):
        super().__init__()
        self.year = year
        self.month = month

    def run(self):
        try:
            conn = None
            schedule_data = []
            events_data = []
            users_data = []

            try:
                conn = DatabaseConnector.get_connection()
                cursor = conn.cursor()

                # Grafik - optymalne zapytanie
                print("Pobieranie danych grafiku...")
                schedule_query = """
                SELECT 
                    k.WydzialGrafik, k.PrzelozonyDane, k.UzytkownikDane, k.Uzytkownik,
                    CONVERT(VARCHAR(10),g.Data,120), g.Symbol,
                    DATEDIFF(hour,DataOd,DataDo), g.Id
                FROM p_v_zz_GrafikiPracy g
                JOIN p_t_do_KonfiguracjaZatrudnienie k                
                ON k.Uzytkownik = g.Uzytkownik 
                   AND k.Rok = g.Rok AND k.Miesiac = g.Miesiac
                WHERE g.Rok = ? AND g.Miesiac = ? AND k.Flaga = 1
                """
                cursor.execute(schedule_query, (self.year, self.month))
                schedule_data = cursor.fetchall()
                print(f"Pobrano {len(schedule_data)} wpisów grafiku")

                # Zdarzenia - optymalne zapytanie z limitem kolumn
                print("Pobieranie danych zdarzeń...")
                events_query = """
                SELECT 'Spotkanie', Temat, Nazwa, Uzytkownik, Data, DataOd, DataDo, StatusNazwa, Id
                FROM p_v_zz_Spotkania
                WHERE Rok = ? AND Miesiac = ? AND Status = 1
                UNION ALL
                SELECT 'Szkolenie', Temat, Nazwa, Uzytkownik, Data, DataOd, DataDo, StatusNazwa, Id
                FROM p_v_zz_Szkolenia
                WHERE Rok = ? AND Miesiac = ? AND Status = 1
                UNION ALL
                SELECT 'Nadgodziny', 'Nadgodziny', 'Nadgodziny', Uzytkownik, Data, DataOd, DataDo, 'Wstawione', Id
                FROM p_t_zz_Nadgodziny
                WHERE Rok = ? AND Miesiac = ? AND [StatusRozliczenia] = 1
                """
                cursor.execute(events_query, (self.year, self.month, self.year, self.month, self.year, self.month))
                events_data = cursor.fetchall()
                print(f"Pobrano {len(events_data)} zdarzeń")

                # Użytkownicy - minimalne dane
                print("Pobieranie danych użytkowników...")
                users_query = """
                SELECT Uzytkownik, WydzialGrafik, PrzelozonyDane, UzytkownikDane
                FROM p_t_do_KonfiguracjaZatrudnienie
                WHERE Rok = ? AND Miesiac = ? AND Flaga = 1
                """
                cursor.execute(users_query, (self.year, self.month))
                users_data = cursor.fetchall()
                print(f"Pobrano {len(users_data)} użytkowników")

            finally:
                if conn:
                    conn.close()

            # Wyślij dane jeśli udało się cokolwiek pobrać
            self.data_fetched.emit([schedule_data, events_data, users_data])

        except Exception as e:
            print(f"Błąd podczas pobierania danych: {e}")
            self.data_fetched.emit([])


class WeekendAwareHeaderView(QHeaderView):
    """Niestandardowy nagłówek tabeli, który koloruje weekendy"""

    def __init__(self, orientation, parent=None):
        super().__init__(orientation, parent)
        self.weekend_columns = set()
        self.dark_theme = False
        self.setSectionsClickable(True)  # Ważne, aby sekcje były klikalne

    def set_weekend_columns(self, weekend_cols, dark_theme=False):
        """Ustawia kolumny, które powinny być oznaczone jako weekendy"""
        self.weekend_columns = set(weekend_cols)
        self.dark_theme = dark_theme
        self.viewport().update()  # Wymusza odświeżenie widoku

    def paintSection(self, painter, rect, logicalIndex):
        """Nadpisuje metodę malowania sekcji nagłówka"""
        # Zapisz aktualny kolor i czcionkę
        old_pen = painter.pen()
        old_font = painter.font()

        # Sprawdź, czy to weekend
        if logicalIndex in self.weekend_columns:
            # Ustaw czerwony kolor
            if self.dark_theme:
                painter.setPen(QColor(255, 99, 71))  # Tomato red dla ciemnego motywu
            else:
                painter.setPen(QColor(220, 20, 60))  # Crimson dla jasnego motywu

            # Możesz opcjonalnie ustawić pogrubioną czcionkę dla weekendów
            font = painter.font()
            font.setBold(True)
            painter.setFont(font)

        # Maluj sekcję standardowo
        super().paintSection(painter, rect, logicalIndex)

        # Przywróć poprzedni kolor i czcionkę
        painter.setPen(old_pen)
        painter.setFont(old_font)


class WorkScheduleWindow(QMainWindow):
    def __init__(self):
        super().__init__()

        self.setWindowTitle("TeamFlowApp")
        self.setGeometry(100, 100, 1200, 800)

        # Inicjalizacja bazy danych ustawień
        self.settings_db = SettingsDatabase()

        # Załaduj ustawienia użytkownika
        user_settings = self.settings_db.load_settings()

        # Zapisz ustawienia motywu z bazy danych
        self.is_dark_theme = user_settings['theme'] == 'dark'
        self.current_font = user_settings['font_family']
        self.current_font_size = user_settings['font_size']

        # Zastosuj czcionkę globalnie dla całej aplikacji
        font = QFont(self.current_font, self.current_font_size)
        QApplication.setFont(font)

        # Zastosuj bazowy styl dla motywu ciemnego/jasnego przed utworzeniem UI
        if self.is_dark_theme:
            self.setStyleSheet("""
                QMainWindow, QWidget {
                    background-color: #1e1e1e;
                    color: white;
                }
                QPushButton {
                    background-color: #2c2c2c;
                    color: white;
                    border: 1px solid #3a3a3a;
                    padding: 5px;
                    border-radius: 3px;
                }
                QComboBox {
                    background-color: #2c2c2c;
                    color: white;
                    border: 1px solid #3a3a3a;
                    padding: 5px;
                    border-radius: 3px;
                }
                QMessageBox {
                    background-color: #1e1e1e;
                    color: white;
                }
                QMessageBox QPushButton {
                    background-color: #2c2c2c;
                    color: white;
                    border: 1px solid #3a3a3a;
                    padding: 5px;
                    border-radius: 3px;
                }
            """)
        else:
            self.setStyleSheet("""
                QMainWindow, QWidget {
                    background-color: #f5f5f5;
                    color: black;
                }
                QPushButton {
                    background-color: #e0e0e0;
                    color: black;
                    border: 1px solid #cccccc;
                    padding: 5px;
                    border-radius: 3px;
                }
                QComboBox {
                    background-color: white;
                    color: black;
                    border: 1px solid #cccccc;
                    padding: 5px;
                    border-radius: 3px;
                }
                QMessageBox {
                    background-color: #f5f5f5;
                    color: black;
                }
                QMessageBox QPushButton {
                    background-color: #e0e0e0;
                    color: black;
                    border: 1px solid #cccccc;
                    padding: 5px;
                    border-radius: 3px;
                }
            """)

        # Dane
        self.raw_data = []
        self.processed_data = {}
        self.visible_rows = []
        self.last_modification_date = None
        self.all_events_data = []  # Bufor na wszystkie zdarzenia
        self.user_info_map = {}  # Mapowanie użytkowników na ich dane (wydział, przełożony, nazwa)

        # Utworzenie interfejsu
        self.setup_ui()

        # Zastosuj pełny zestaw stylów dla całej aplikacji
        self.apply_theme_settings(
            'dark' if self.is_dark_theme else 'light',
            self.current_font,
            self.current_font_size
        )

        # Pobieranie początkowych danych
        self.current_date = QDate.currentDate()
        self.update_data(self.current_date.year(), self.current_date.month())

        # Ustaw daty filtrowania po inicjalizacji danych
        self.update_filter_dates()


    def log_time(self, label, start_time):
        """Pomocnicza funkcja do logowania czasu"""
        end_time = time.time()
        elapsed = end_time - start_time
        print(f"[CZAS] {label}: {elapsed:.3f} sekundy")
        return end_time

    def setup_ui(self):
        # Główny widget i layout
        central_widget = QWidget()
        main_layout = QVBoxLayout(central_widget)
        main_layout.setContentsMargins(10, 10, 10, 10)
        main_layout.setSpacing(10)

        # ------------ CZĘŚĆ 1: GÓRNY PASEK ------------
        top_bar_frame = QFrame()
        top_bar_frame.setFrameShape(QFrame.StyledPanel)
        top_bar_frame.setFrameShadow(QFrame.Raised)
        top_bar_layout = QHBoxLayout(top_bar_frame)
        top_bar_layout.setContentsMargins(5, 5, 5, 5)

        # Przycisk zmiany motywu
        self.theme_button = QPushButton("Zmień motyw")
        self.theme_button.clicked.connect(self.show_theme_settings)
        # Zastosuj bazowy styl zgodny z motywem
        if self.is_dark_theme:
            self.theme_button.setStyleSheet("""
                background-color: #2c2c2c;
                color: white;
                border: 1px solid #3a3a3a;
                padding: 5px;
                border-radius: 3px;
            """)
        else:
            self.theme_button.setStyleSheet("""
                background-color: #e0e0e0;
                color: black;
                border: 1px solid #cccccc;
                padding: 5px;
                border-radius: 3px;
            """)

        # Etykieta i combobox na rok-miesiąc
        date_label = QLabel("Miesiąc:")
        self.date_combo = QComboBox()

        # Zastosuj styl zgodny z motywem dla comboboxa
        if self.is_dark_theme:
            self.date_combo.setStyleSheet("""
                background-color: #2c2c2c;
                color: white;
                border: 1px solid #3a3a3a;
                padding: 5px;
                border-radius: 3px;
            """)
        else:
            self.date_combo.setStyleSheet("""
                background-color: white;
                color: black;
                border: 1px solid #cccccc;
                padding: 5px;
                border-radius: 3px;
            """)

        # Dodanie opcji dla 3 miesięcy wstecz i 1 miesiąca do przodu od bieżącego
        current_date = datetime.now()
        months_to_show = []

        # Generowanie listy miesięcy (3 wstecz, bieżący, 1 do przodu)
        for i in range(-3, 2):
            date = current_date.replace(day=1)
            date = date + timedelta(days=32 * i)
            date = date.replace(day=1)  # Pierwszy dzień miesiąca
            months_to_show.append((date.year, date.month))

        # Dodanie miesięcy do comboboxa w formacie YYYY-MM
        for year, month in months_to_show:
            self.date_combo.addItem(f"{year}-{month:02d}", (year, month))

        # Ustawienie bieżącego miesiąca
        current_month_idx = 3  # Indeks bieżącego miesiąca w liście (4. element)
        self.date_combo.setCurrentIndex(current_month_idx)

        # Podłącz sygnał zmiany comboboxa daty
        self.date_combo.currentIndexChanged.connect(self.on_date_combo_changed)

        # Przycisk odświeżania
        self.refresh_button = QPushButton("Odśwież dane")
        self.refresh_button.clicked.connect(self.refresh_data)
        # Zastosuj bazowy styl zgodny z motywem
        if self.is_dark_theme:
            self.refresh_button.setStyleSheet("""
                background-color: #2c2c2c;
                color: white;
                border: 1px solid #3a3a3a;
                padding: 5px;
                border-radius: 3px;
            """)
        else:
            self.refresh_button.setStyleSheet("""
                background-color: #e0e0e0;
                color: black;
                border: 1px solid #cccccc;
                padding: 5px;
                border-radius: 3px;
            """)

        # Dodanie widgetów do layoutu górnego paska
        top_bar_layout.addWidget(self.theme_button)
        top_bar_layout.addWidget(date_label)
        top_bar_layout.addWidget(self.date_combo)
        top_bar_layout.addWidget(self.refresh_button)
        top_bar_layout.addStretch()

        # Dodaj górny pasek do głównego layoutu
        main_layout.addWidget(top_bar_frame)

        # ------------ CZĘŚĆ 2 i 3: ŚRODKOWA CZĘŚĆ ------------
        # Główny kontener na środkową część (filtry po lewej, tabela po prawej)
        main_splitter = QSplitter(Qt.Horizontal)
        middle_container = QWidget()
        middle_layout = QHBoxLayout(middle_container)
        middle_layout.setContentsMargins(0, 0, 0, 0)
        middle_layout.setSpacing(10)

        # ------------ CZĘŚĆ 2: LEWY PANEL FILTRÓW ------------
        self._left_panel = QWidget()
        # Możesz ustawić minimalną szerokość, aby panel nie znikał
        self._left_panel.setMinimumWidth(150)
        if self.is_dark_theme:
            self._left_panel.setStyleSheet("background-color: #1e1e1e; color: white;")
        else:
            self._left_panel.setStyleSheet("background-color: #f0f0f0; color: black;")

        filters_layout = QVBoxLayout(self._left_panel)
        filters_layout.setContentsMargins(10, 10, 10, 10)

        # Tytuł filtrów
        filters_title = QLabel("Filtry")
        if self.is_dark_theme:
            filters_title.setStyleSheet("font-size: 16px; font-weight: bold; color: white;")
        else:
            filters_title.setStyleSheet("font-size: 16px; font-weight: bold; color: black;")
        filters_layout.addWidget(filters_title)

        # Filtr wydziału
        wydzial_label = QLabel("Wydział:")
        if self.is_dark_theme:
            wydzial_label.setStyleSheet("color: #3498db;")
        else:
            wydzial_label.setStyleSheet("color: #2980b9;")
        filters_layout.addWidget(wydzial_label)

        # Lista wydziałów
        self.wydzial_list = QListWidget()
        self.wydzial_list.setSelectionMode(QAbstractItemView.ExtendedSelection)
        if self.is_dark_theme:
            self.wydzial_list.setStyleSheet("""
                QListWidget {
                    background-color: #2c2c2c;
                    color: white;
                    border: 1px solid #3a3a3a;
                    border-radius: 3px;
                }
                QListWidget::item {
                    padding: 3px;
                }
                QListWidget::item:selected {
                    background-color: #3498db;
                }
            """)
        else:
            self.wydzial_list.setStyleSheet("""
                QListWidget {
                    background-color: white;
                    color: black;
                    border: 1px solid #cccccc;
                    border-radius: 3px;
                }
                QListWidget::item {
                    padding: 3px;
                }
                QListWidget::item:selected {
                    background-color: #3498db;
                    color: white;
                }
            """)
        self.wydzial_list.setFixedHeight(120)

        # Dodaj pole wyszukiwania dla wydziałów
        self.wydzial_filter = QLineEdit()
        self.wydzial_filter.setPlaceholderText("Filtruj wydział...")
        if self.is_dark_theme:
            self.wydzial_filter.setStyleSheet("""
                QLineEdit {
                    background-color: #2c2c2c;
                    color: white;
                    border: 1px solid #3a3a3a;
                    padding: 5px;
                    border-radius: 3px;
                }
            """)
        else:
            self.wydzial_filter.setStyleSheet("""
                QLineEdit {
                    background-color: white;
                    color: black;
                    border: 1px solid #cccccc;
                    padding: 5px;
                    border-radius: 3px;
                }
            """)
        self.wydzial_filter.textChanged.connect(self.filter_wydzial_list)

        filters_layout.addWidget(self.wydzial_filter)
        filters_layout.addWidget(self.wydzial_list)

        # Filtr przełożonego
        przelozony_label = QLabel("Przełożony:")
        if self.is_dark_theme:
            przelozony_label.setStyleSheet("color: #3498db;")
        else:
            przelozony_label.setStyleSheet("color: #2980b9;")
        filters_layout.addWidget(przelozony_label)

        # Lista przełożonych
        self.przelozony_list = QListWidget()
        self.przelozony_list.setSelectionMode(QAbstractItemView.ExtendedSelection)
        if self.is_dark_theme:
            self.przelozony_list.setStyleSheet("""
                QListWidget {
                    background-color: #2c2c2c;
                    color: white;
                    border: 1px solid #3a3a3a;
                    border-radius: 3px;
                }
                QListWidget::item {
                    padding: 3px;
                }
                QListWidget::item:selected {
                    background-color: #3498db;
                }
            """)
        else:
            self.przelozony_list.setStyleSheet("""
                QListWidget {
                    background-color: white;
                    color: black;
                    border: 1px solid #cccccc;
                    border-radius: 3px;
                }
                QListWidget::item {
                    padding: 3px;
                }
                QListWidget::item:selected {
                    background-color: #3498db;
                    color: white;
                }
            """)
        self.przelozony_list.setFixedHeight(150)

        # Dodaj pole wyszukiwania dla przełożonych
        self.przelozony_filter = QLineEdit()
        self.przelozony_filter.setPlaceholderText("Filtruj przełożonych...")
        if self.is_dark_theme:
            self.przelozony_filter.setStyleSheet("""
                QLineEdit {
                    background-color: #2c2c2c;
                    color: white;
                    border: 1px solid #3a3a3a;
                    padding: 5px;
                    border-radius: 3px;
                }
            """)
        else:
            self.przelozony_filter.setStyleSheet("""
                QLineEdit {
                    background-color: white;
                    color: black;
                    border: 1px solid #cccccc;
                    padding: 5px;
                    border-radius: 3px;
                }
            """)
        self.przelozony_filter.textChanged.connect(self.filter_przelozony_list)

        filters_layout.addWidget(self.przelozony_filter)
        filters_layout.addWidget(self.przelozony_list)

        # Filtr użytkownika
        uzytkownik_label = QLabel("Użytkownik:")
        if self.is_dark_theme:
            uzytkownik_label.setStyleSheet("color: #3498db;")
        else:
            uzytkownik_label.setStyleSheet("color: #2980b9;")
        filters_layout.addWidget(uzytkownik_label)

        # Lista użytkowników
        self.uzytkownik_list = QListWidget()
        self.uzytkownik_list.setSelectionMode(QAbstractItemView.ExtendedSelection)
        if self.is_dark_theme:
            self.uzytkownik_list.setStyleSheet("""
                QListWidget {
                    background-color: #2c2c2c;
                    color: white;
                    border: 1px solid #3a3a3a;
                    border-radius: 3px;
                }
                QListWidget::item {
                    padding: 3px;
                }
                QListWidget::item:selected {
                    background-color: #3498db;
                }
            """)
        else:
            self.uzytkownik_list.setStyleSheet("""
                QListWidget {
                    background-color: white;
                    color: black;
                    border: 1px solid #cccccc;
                    border-radius: 3px;
                }
                QListWidget::item {
                    padding: 3px;
                }
                QListWidget::item:selected {
                    background-color: #3498db;
                    color: white;
                }
            """)
        self.uzytkownik_list.setFixedHeight(180)

        # Dodaj pole wyszukiwania dla użytkowników
        self.uzytkownik_filter = QLineEdit()
        self.uzytkownik_filter.setPlaceholderText("Filtruj użytkowników...")
        if self.is_dark_theme:
            self.uzytkownik_filter.setStyleSheet("""
                QLineEdit {
                    background-color: #2c2c2c;
                    color: white;
                    border: 1px solid #3a3a3a;
                    padding: 5px;
                    border-radius: 3px;
                }
            """)
        else:
            self.uzytkownik_filter.setStyleSheet("""
                QLineEdit {
                    background-color: white;
                    color: black;
                    border: 1px solid #cccccc;
                    padding: 5px;
                    border-radius: 3px;
                }
            """)
        self.uzytkownik_filter.textChanged.connect(self.filter_uzytkownik_list)

        filters_layout.addWidget(self.uzytkownik_filter)
        filters_layout.addWidget(self.uzytkownik_list)

        # Przycisk wyczyść filtry
        clear_filters_button = QPushButton("Wyczyść filtry")
        # Zastosuj bazowy styl zgodny z motywem (taki sam jak inne przyciski)
        if self.is_dark_theme:
            clear_filters_button.setStyleSheet("""
                background-color: #2c2c2c;
                color: white;
                border: 1px solid #3a3a3a;
                padding: 5px;
                border-radius: 3px;
            """)
        else:
            clear_filters_button.setStyleSheet("""
                background-color: #e0e0e0;
                color: black;
                border: 1px solid #cccccc;
                padding: 5px;
                border-radius: 3px;
            """)
        clear_filters_button.clicked.connect(self.clear_filters)
        filters_layout.addStretch()
        filters_layout.addWidget(clear_filters_button)
        # Zapisz referencję do przycisku "Wyczyść filtry", aby móc go stylizować w apply_theme_settings
        self.clear_filters_button = clear_filters_button

        # Podłączenie sygnałów zmiany filtrów
        self.wydzial_list.itemSelectionChanged.connect(self.filter_data)
        self.przelozony_list.itemSelectionChanged.connect(self.filter_data)
        self.uzytkownik_list.itemSelectionChanged.connect(self.filter_data)

        # ------------ CZĘŚĆ 3: PRAWY PANEL Z TABELAMI ------------
        right_panel = QWidget()
        right_layout = QVBoxLayout(right_panel)
        right_layout.setContentsMargins(0, 0, 0, 0)
        right_layout.setSpacing(10)

        # Splitter pionowy dla prawego panelu (grafik | zdarzenia)
        right_splitter = QSplitter(Qt.Vertical)

        # ------------ Tabela z grafikiem (Górna część prawego panelu) ------------
        schedule_frame = QFrame()
        schedule_frame.setFrameShape(QFrame.StyledPanel)
        schedule_frame.setFrameShadow(QFrame.Raised)
        schedule_layout = QVBoxLayout(schedule_frame)
        schedule_layout.setContentsMargins(5, 5, 5, 5)

        # Tabela z grafikiem
        self.table = QTableWidget()
        self.table.setSelectionMode(QAbstractItemView.ExtendedSelection)  # Umożliwia zaznaczanie wielu komórek
        self.table.setSelectionBehavior(QAbstractItemView.SelectItems)  # Zaznaczanie pojedynczych komórek
        self.table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.table.itemSelectionChanged.connect(self.on_selection_changed)

        # Zastąp standardowy nagłówek poziomy niestandardowym
        self.table.setHorizontalHeader(WeekendAwareHeaderView(Qt.Horizontal, self.table))

        # Dodaj tabelę do layoutu
        schedule_layout.addWidget(self.table)

        # Dodaj przycisk "Wstaw symbol" z skrótem klawiszowym i podpowiedzią
        symbol_button_frame = QFrame()
        symbol_button_layout = QHBoxLayout(symbol_button_frame)
        symbol_button_layout.setContentsMargins(0, 0, 0, 0)

        self.insert_symbol_button = QPushButton("Wstaw symbol")
        self.insert_symbol_button.setShortcut("Ctrl+I")  # Skrót klawiszowy Ctrl+I
        self.insert_symbol_button.setToolTip("Wstaw symbol (Ctrl+I)")  # Podpowiedź z informacją o skrócie

        # Zastosuj bazowy styl zgodny z motywem
        if self.is_dark_theme:
            self.insert_symbol_button.setStyleSheet("""
                background-color: #2c2c2c;
                color: white;
                border: 1px solid #3a3a3a;
                padding: 5px;
                border-radius: 3px;
            """)
        else:
            self.insert_symbol_button.setStyleSheet("""
                background-color: #e0e0e0;
                color: black;
                border: 1px solid #cccccc;
                padding: 5px;
                border-radius: 3px;
            """)
        self.insert_symbol_button.clicked.connect(self.show_insert_symbol_dialog)
        symbol_button_layout.addWidget(self.insert_symbol_button)
        symbol_button_layout.addStretch()

        schedule_layout.addWidget(symbol_button_frame)

        # Dodaj panel grafiku do prawego panelu
        right_layout.addWidget(schedule_frame)

        separator_top = QFrame()
        separator_top.setFrameShape(QFrame.HLine)
        separator_top.setFrameShadow(QFrame.Sunken)
        separator_top.setStyleSheet("background-color: transparent;")  # Ukryj górny separator
        self.separator_top = separator_top
        right_layout.addWidget(separator_top)

        # ------------ CZĘŚĆ 4: PANEL ZDARZEŃ ------------
        events_frame = QFrame()
        events_frame.setFrameShape(QFrame.StyledPanel)
        events_frame.setFrameShadow(QFrame.Raised)
        events_layout = QVBoxLayout(events_frame)
        events_layout.setContentsMargins(5, 5, 5, 5)

        # Tworzenie kontrolek filtrów dla tabeli zdarzeń
        events_filter_frame = QFrame()
        events_filter_layout = QHBoxLayout(events_filter_frame)
        events_filter_layout.setContentsMargins(0, 0, 0, 0)

        # Filtry daty od-do
        date_from_label = QLabel("Data od:")
        self.date_from = QDateEdit()
        self.date_from.setDisplayFormat("dd.MM.yyyy")
        self.date_from.setDate(QDate.currentDate().addDays(-30))
        self.date_from.setCalendarPopup(True)

        date_to_label = QLabel("Data do:")
        self.date_to = QDateEdit()
        self.date_to.setDisplayFormat("dd.MM.yyyy")
        self.date_to.setDate(QDate.currentDate())
        self.date_to.setCalendarPopup(True)

        # Filtr tematu
        topic_label = QLabel("Temat:")
        self.topic_filter = QLineEdit()
        self.topic_filter.setPlaceholderText("Filtruj po temacie...")

        # Filtr nazwy
        name_label = QLabel("Nazwa:")
        self.name_filter = QLineEdit()
        self.name_filter.setPlaceholderText("Filtruj po nazwie...")

        # Checkbox do filtrowania spotkań
        self.meetings_checkbox = QCheckBox("Spotkania")
        self.meetings_checkbox.setChecked(True)
        self.meetings_checkbox.stateChanged.connect(self.filter_events_table)

        # Checkbox do filtrowania szkoleń
        self.trainings_checkbox = QCheckBox("Szkolenia")
        self.trainings_checkbox.setChecked(True)
        self.trainings_checkbox.stateChanged.connect(self.filter_events_table)

        # Checkbox do filtrowania nadgodzin
        self.overtime_checkbox = QCheckBox("Nadgodziny")
        self.overtime_checkbox.setChecked(True)
        self.overtime_checkbox.stateChanged.connect(self.filter_events_table)

        # Przycisk filtrowania
        self.filter_button = QPushButton("Filtruj")
        self.filter_button.clicked.connect(self.filter_events_by_date_range)

        # Dodaj kontrolki do layoutu filtrów zdarzeń
        events_filter_layout.addWidget(date_from_label)
        events_filter_layout.addWidget(self.date_from)
        events_filter_layout.addWidget(date_to_label)
        events_filter_layout.addWidget(self.date_to)
        events_filter_layout.addWidget(topic_label)
        events_filter_layout.addWidget(self.topic_filter)
        events_filter_layout.addWidget(name_label)
        events_filter_layout.addWidget(self.name_filter)
        events_filter_layout.addWidget(self.meetings_checkbox)
        events_filter_layout.addWidget(self.trainings_checkbox)
        events_filter_layout.addWidget(self.overtime_checkbox)
        events_filter_layout.addWidget(self.filter_button)
        events_filter_layout.addStretch()

        # Dodaj panel filtrów zdarzeń do layoutu panelu zdarzeń
        events_layout.addWidget(events_filter_frame)

        # Tworzenie tabeli zdarzeń
        self.events_table = QTableWidget()
        self.events_table.setSelectionMode(QAbstractItemView.ExtendedSelection)
        self.events_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.events_table.setEditTriggers(QAbstractItemView.NoEditTriggers)

        # Ustawienie kolumn dla tabeli zdarzeń
        self.events_table.setColumnCount(9)
        self.events_table.setHorizontalHeaderLabels([
            "Typ", "Temat", "Nazwa", "Użytkownik", "Data", "Od", "Do", "Status", "Akcje"
        ])

        # Ustaw szerokość kolumn
        self.events_table.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeToContents)  # Typ
        self.events_table.horizontalHeader().setSectionResizeMode(1, QHeaderView.Stretch)  # Temat
        self.events_table.horizontalHeader().setSectionResizeMode(2, QHeaderView.Stretch)  # Nazwa
        self.events_table.horizontalHeader().setSectionResizeMode(3, QHeaderView.ResizeToContents)  # Użytkownik
        self.events_table.horizontalHeader().setSectionResizeMode(4, QHeaderView.ResizeToContents)  # Data
        self.events_table.horizontalHeader().setSectionResizeMode(5, QHeaderView.ResizeToContents)  # Od
        self.events_table.horizontalHeader().setSectionResizeMode(6, QHeaderView.ResizeToContents)  # Do
        self.events_table.horizontalHeader().setSectionResizeMode(7, QHeaderView.ResizeToContents)  # Status
        self.events_table.horizontalHeader().setSectionResizeMode(8, QHeaderView.ResizeToContents)  # Akcje

        # Aplikuj styl do tabeli zdarzeń
        if self.is_dark_theme:
            self.events_table.setStyleSheet("""
                QTableWidget {
                    background-color: #2c2c2c;
                    color: white;
                    gridline-color: #3a3a3a;
                    border: 1px solid #3a3a3a;
                }
                QTableWidget::item {
                    color: white;
                }
                QTableWidget::item:selected {
                    background-color: #3498db;
                }
            """)
        else:
            self.events_table.setStyleSheet("""
                QTableWidget {
                    background-color: white;
                    color: black;
                    gridline-color: #cccccc;
                    border: 1px solid #cccccc;
                }
                QTableWidget::item {
                    color: black;
                }
                QTableWidget::item:selected {
                    background-color: #3498db;
                    color: white;
                }
            """)

        # Dodaj tabelę zdarzeń do panelu zdarzeń
        events_layout.addWidget(self.events_table)

        # Dodaj panel zdarzeń do prawego panelu
        right_layout.addWidget(events_frame)

        # Inicjalizacja danych w tabeli zdarzeń
        self.events_data = []  # Lista słowników z danymi o zdarzeniach

        # Podłącz sygnały do filtrów
        self.topic_filter.textChanged.connect(self.filter_events_table)
        self.name_filter.textChanged.connect(self.filter_events_table)

        # Dodaj lewy i prawy panel do środkowego kontenera
        middle_layout.addWidget(self._left_panel)
        middle_layout.addWidget(right_panel, 1)  # Dodaj wagę, aby prawy panel zajmował więcej miejsca

        # Dodaj środkowy kontener do głównego layoutu
        main_layout.addWidget(middle_container, 0)  # Dodaj wagę, aby środkowy kontener rozciągał się

        # Dodaj panele do pionowego splittera
        right_splitter.addWidget(schedule_frame)
        right_splitter.addWidget(events_frame)

        # Ustaw początkowe proporcje dla pionowego splittera (np. 60% grafik, 40% zdarzenia)
        right_splitter.setSizes([600, 400])

        # Dodaj pionowy splitter do layoutu prawego panelu
        right_layout.addWidget(right_splitter)

        # Dodaj panele do głównego splittera
        main_splitter.addWidget(self._left_panel)
        main_splitter.addWidget(right_panel)

        # Ustaw początkowe proporcje dla głównego splittera (np. 25% lewy panel, 75% prawy panel)
        main_splitter.setSizes([250, 950])

        # Dodaj główny splitter do głównego layoutu
        main_layout.addWidget(main_splitter, 1)  # Waga 1 zapewnia rozciąganie

        # Ustawienie głównego widgetu
        self.setCentralWidget(central_widget)

        # Ukryj nagłówek pionowy (numery wierszy)
        self.table.verticalHeader().setVisible(False)
        self.events_table.verticalHeader().setVisible(False)

    def show_insert_symbol_dialog(self):
        """Pokazuje okno dialogowe do wstawiania symbolu"""
        dialog = InsertSymbolDialog(self)
        if dialog.exec():
            symbol = dialog.get_selected_symbol()
            # Pobierz zaznaczone komórki
            selected_ranges = self.table.selectedRanges()
            current_data = self.date_combo.currentData()

            if not current_data:
                QMessageBox.warning(
                    self,
                    "Brak danych",
                    "Nie wybrano miesiąca lub brak dostępnych danych do wyświetlenia.",
                    QMessageBox.Ok
                )
                return

            if not selected_ranges:
                QMessageBox.warning(
                    self,
                    "Brak zaznaczenia",
                    "Nie zaznaczono żadnych komórek do aktualizacji.",
                    QMessageBox.Ok
                )
                return

            year, month_idx = current_data

            # Oblicz liczbę dni w miesiącu
            if month_idx in [4, 6, 9, 11]:
                days_in_month = 30
            elif month_idx == 2:
                if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0):
                    days_in_month = 29
                else:
                    days_in_month = 28
            else:
                days_in_month = 31

            processed_keys = list(self.processed_data.keys())
            selected_cells = []

            for range_item in selected_ranges:
                top_row = max(0, range_item.topRow())
                bottom_row = min(range_item.bottomRow(), len(self.visible_rows) - 1)
                left_col = max(3, range_item.leftColumn())
                right_col = min(range_item.rightColumn(), 2 + days_in_month)

                for table_row in range(top_row, bottom_row + 1):
                    data_row = self.visible_rows[table_row]
                    if data_row >= len(processed_keys):
                        continue

                    key = processed_keys[data_row]
                    wydzial, przelozony, uzytkownik_dane, uzytkownik = key

                    for col in range(left_col, right_col + 1):
                        day = col - 2
                        day_data = self.processed_data[key]['days'].get(day)
                        if day_data:
                            selected_cells.append({
                                'wydzial': wydzial,
                                'przelozony': przelozony,
                                'uzytkownik_dane': uzytkownik_dane,
                                'uzytkownik_id': uzytkownik,
                                'day': day,
                                'symbol': day_data.get('symbol'),
                                'hours': day_data.get('hours'),
                                'id': day_data.get('id')
                            })

            if not selected_cells:
                QMessageBox.information(
                    self,
                    "Brak danych",
                    "Nie znaleziono danych dla zaznaczonych komórek.",
                    QMessageBox.Ok
                )
                return

            # Wywołaj update_selected_cells z symbolem i zaznaczonymi komórkami
            self.update_selected_cells(symbol=symbol, selected_cells=selected_cells)

    def update_filter_dates(self):
        """Aktualizuje daty filtrowania do pierwszego i ostatniego dnia wybranego miesiąca"""
        current_data = self.date_combo.currentData()
        if not current_data:
            return

        year, month = current_data

        # Pierwszy dzień miesiąca
        first_day = QDate(year, month, 1)
        self.date_from.setDate(first_day)

        # Ostatni dzień miesiąca (przejdź do następnego miesiąca i cofnij o 1 dzień)
        if month == 12:
            next_month = QDate(year + 1, 1, 1)
        else:
            next_month = QDate(year, month + 1, 1)

        last_day = next_month.addDays(-1)
        self.date_to.setDate(last_day)

    def on_date_combo_changed(self):
        """Obsługuje zmianę wybranego miesiąca"""
        # Pobierz rok i miesiąc
        current_data = self.date_combo.currentData()
        if current_data:
            year, month = current_data
            # Aktualizuj dane
            self.update_data(year, month)
            # Aktualizuj daty filtrowania
            self.update_filter_dates()

    def get_selected_schedule_cells(self):
        """Zwraca listę zaznaczonych komórek z grafikiem"""
        selected_cells = []
        selected_ranges = self.table.selectedRanges()

        # Pobierz aktualny rok i miesiąc
        current_data = self.date_combo.currentData()
        if not current_data:
            return selected_cells
        year, month_idx = current_data

        # Określ liczbę dni w miesiącu
        if month_idx in [4, 6, 9, 11]:
            days_in_month = 30
        elif month_idx == 2:
            if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0):
                days_in_month = 29
            else:
                days_in_month = 28
        else:
            days_in_month = 31

        for range_item in selected_ranges:
            for table_row in range(range_item.topRow(), range_item.bottomRow() + 1):
                for col in range(range_item.leftColumn(), range_item.rightColumn() + 1):
                    # Sprawdź, czy to komórka z grafikiem
                    if col >= 3 and col < 3 + days_in_month:
                        if table_row < len(self.visible_rows):
                            data_row = self.visible_rows[table_row]
                            if data_row < len(self.processed_data):
                                key = list(self.processed_data.keys())[data_row]
                                wydzial, przelozony, uzytkownik_dane, uzytkownik = key
                                day = col - 2
                                day_data = self.processed_data[key]['days'].get(day)
                                if day_data and day_data.get('id'):
                                    selected_cells.append({
                                        'user_id': uzytkownik,
                                        'day': day,
                                        'date': QDate(year, month_idx, day).toString('yyyy-MM-dd'),
                                        'id': day_data['id'],
                                        'current_symbol': day_data.get('symbol', '')
                                    })
        return selected_cells

    def update_selected_cells(self, symbol=None, selected_cells=None):
        """Aktualizuje listę zaznaczonych komórek i ładuje zdarzenia, opcjonalnie wstawia symbol"""
        # Jeśli selected_cells nie jest przekazane, pobierz je z tabeli
        if selected_cells is None:
            selected_ranges = self.table.selectedRanges()
            current_data = self.date_combo.currentData()

            if not current_data:
                QMessageBox.warning(
                    self,
                    "Brak danych",
                    "Nie wybrano miesiąca lub brak dostępnych danych do wyświetlenia.",
                    QMessageBox.Ok
                )
                return

            if not selected_ranges:
                year, month = current_data
                self.load_all_events_for_month(year, month)
                return

            # Pobierz rok i miesiąc tylko raz
            year, month_idx = current_data

            # Oblicz liczbę dni w miesiącu tylko raz
            if month_idx in [4, 6, 9, 11]:
                days_in_month = 30
            elif month_idx == 2:
                if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0):
                    days_in_month = 29
                else:
                    days_in_month = 28
            else:
                days_in_month = 31

            # Przygotuj listę kluczy z self.processed_data raz
            processed_keys = list(self.processed_data.keys())

            selected_cells = []
            for range_item in selected_ranges:
                # Ogranicz zakres wierszy do widocznych
                top_row = max(0, range_item.topRow())
                bottom_row = min(range_item.bottomRow(), len(self.visible_rows) - 1)
                # Ogranicz zakres kolumn do dni miesiąca
                left_col = max(3, range_item.leftColumn())
                right_col = min(range_item.rightColumn(), 2 + days_in_month)

                for table_row in range(top_row, bottom_row + 1):
                    data_row = self.visible_rows[table_row]
                    if data_row >= len(processed_keys):
                        continue

                    key = processed_keys[data_row]
                    wydzial, przelozony, uzytkownik_dane, uzytkownik = key

                    for col in range(left_col, right_col + 1):
                        day = col - 2
                        day_data = self.processed_data[key]['days'].get(day)
                        if day_data:
                            selected_cells.append({
                                'wydzial': wydzial,
                                'przelozony': przelozony,
                                'uzytkownik_dane': uzytkownik_dane,
                                'uzytkownik_id': uzytkownik,
                                'day': day,
                                'symbol': day_data.get('symbol'),
                                'hours': day_data.get('hours'),
                                'id': day_data.get('id')
                            })

            if not selected_cells:
                QMessageBox.information(
                    self,
                    "Brak danych",
                    "Nie znaleziono danych dla zaznaczonych komórek.",
                    QMessageBox.Ok
                )

        # Jeśli podano symbol, zaktualizuj grafik
        if symbol and selected_cells:
            # Przygotuj tekstową informację o zmianach
            changes_info = ""
            for i, cell in enumerate(selected_cells[:10]):  # Pokaż max 10 przykładów
                changes_info += f"{i + 1}. Użytkownik: {cell['uzytkownik_dane']}, Dzień: {cell['day']}, "
                current_symbol = cell['symbol'] or "brak"
                changes_info += f"Symbol: {current_symbol} -> {symbol}\n"

            if len(selected_cells) > 10:
                changes_info += f"... i {len(selected_cells) - 10} więcej\n"

            # Wyświetl komunikat potwierdzenia
            reply = QMessageBox.question(
                self,
                "Potwierdzenie zmiany symbolu",
                f"Czy na pewno chcesz wprowadzić następujące zmiany?\n\n{changes_info}\n"
                f"Łącznie: {len(selected_cells)} komórek",
                QMessageBox.Yes | QMessageBox.No,
                QMessageBox.No
            )

            if reply == QMessageBox.Yes:
                try:
                    conn = DatabaseConnector.get_connection()
                    cursor = conn.cursor()

                    current_data = self.date_combo.currentData()
                    if not current_data:
                        QMessageBox.warning(
                            self,
                            "Brak danych",
                            "Nie wybrano miesiąca do aktualizacji grafiku.",
                            QMessageBox.Ok
                        )
                        return

                    year, month = current_data
                    successful_updates = 0

                    for cell in selected_cells:
                        user_id = cell['uzytkownik_id']
                        day = cell['day']
                        date = QDate(year, month, day).toString('yyyy-MM-dd')

                        # Usuń prefiksy lokalizacji, jeśli istnieją
                        processed_symbol = symbol
                        if symbol and any(prefix in symbol for prefix in ['h;', 's;', 'p;']):
                            # Usuwamy prefiksy h;, s;, p; na początku
                            for prefix in ['h;', 's;', 'p;']:
                                if symbol.startswith(prefix):
                                    processed_symbol = symbol[len(prefix):]
                                    break

                        # Sprawdź, czy rekord już istnieje
                        existing_id = cell.get('id')
                        if existing_id:
                            # Aktualizuj istniejący rekord
                            query = f'''
                            DECLARE @NewSymbol VARCHAR(3) = '{processed_symbol}';
                            UPDATE p_T_ZZ_GrafikiPracy
                            SET Symbol = 
                                CASE 
                                -- Obsługa usuwania lokalizacji (h;, s;, p;)
                                WHEN Symbol LIKE 'h;%' OR Symbol LIKE 's;%' OR Symbol LIKE 'p;%' THEN
                                    CASE
                                        -- Jeśli po lokalizacji jest jeszcze jakiś średnik, zachowaj do ostatniego średnika i dodaj nowy symbol
                                        WHEN 
                                            (SUBSTRING(Symbol, 3, LEN(Symbol)) LIKE '%' + ';') THEN 
                                            SUBSTRING(Symbol, 3, LEN(Symbol) - 2) + @NewSymbol
                                        -- Jeśli po lokalizacji są jakieś średniki w środku
                                        WHEN 
                                            (SUBSTRING(Symbol, 3, LEN(Symbol)) LIKE '%' + ';' + '%') THEN
                                            SUBSTRING(Symbol, 3, LEN(SUBSTRING(Symbol, 3, LEN(Symbol))) - CHARINDEX(';', REVERSE(SUBSTRING(Symbol, 3, LEN(Symbol))))) + ';' + @NewSymbol
                                        -- Jeśli po lokalizacji nie ma już średników
                                        ELSE
                                            SUBSTRING(Symbol, 3, LEN(Symbol)) + ';' + @NewSymbol
                                    END
                                    
                                -- Dla zwykłych przypadków bez lokalizacji
                                WHEN Symbol LIKE '%' + ';' THEN Symbol + @NewSymbol
                                WHEN Symbol LIKE '%' + ';' + '%' THEN
                                    SUBSTRING(Symbol, 1, LEN(Symbol) - CHARINDEX(';', REVERSE(Symbol))) + ';' + @NewSymbol
                                ELSE Symbol + ';' + @NewSymbol
                            END,
                                DataModyfikacji = GETDATE()
                            WHERE Id = {existing_id} ;
                            '''
                            cursor.execute(query)
                            successful_updates += 1
                        else:
                            pass
                            # # Wstaw nowy rekord
                            # query = """
                            # INSERT INTO p_v_do_GrafikPracy (Uzytkownik, Data, Symbol, DataModyfikacji)
                            # VALUES (?, ?, ?, ?)
                            # """
                            # cursor.execute(query, (
                            # user_id, date, processed_symbol, datetime.now().strftime('%Y-%m-%d %H:%M:%S')))
                            # successful_updates += 1

                    conn.commit()
                    conn.close()

                    # Odśwież dane grafiku po aktualizacji
                    self.refresh_data()

                    QMessageBox.information(
                        self,
                        "Sukces",
                        f"Grafik został pomyślnie zaktualizowany. Liczba aktualizacji: {successful_updates}",
                        QMessageBox.Ok
                    )

                except Exception as e:
                    QMessageBox.critical(
                        self,
                        "Błąd",
                        f"Wystąpił błąd podczas aktualizacji grafiku: {str(e)}",
                        QMessageBox.Ok
                    )
                    return

            # Ładuj zdarzenia dla wybranych komórek
            self.load_events_for_selection(selected_cells)

    def load_all_events_to_buffer(self, year, month):
        """Pobiera wszystkie zdarzenia dla wybranego miesiąca i zapisuje je w buforze - zoptymalizowana wersja"""
        try:
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()

            # Zoptymalizowane zapytanie z UNION ALL dla wszystkich typów zdarzeń
            unified_query = """
            SELECT 'Spotkanie' as Typ, Temat, Nazwa, Uzytkownik, Data, DataOd, DataDo, StatusNazwa, Id
            FROM p_v_zz_Spotkania
            WHERE Rok = ? AND Miesiac = ? AND Status = 1
            UNION ALL
            SELECT 'Szkolenie' as Typ, Temat, Nazwa, Uzytkownik, Data, DataOd, DataDo, StatusNazwa, Id
            FROM p_v_zz_Szkolenia
            WHERE Rok = ? AND Miesiac = ? AND Status = 1
            UNION ALL
            SELECT 'Nadgodziny' as Typ, 'Nadgodziny' as Temat, 'Nadgodziny' as Nazwa, Uzytkownik, Data, DataOd, DataDo, 'Wstawione' as StatusNazwa, Id
            FROM p_t_zz_Nadgodziny
            WHERE Rok = ? AND Miesiac = ? AND [StatusRozliczenia] = 1
            """

            # Przygotowanie parametrów (rok, miesiąc dla każdego zapytania w UNION)
            params = (year, month, year, month, year, month)

            # Wykonanie zapytania
            cursor.execute(unified_query, params)
            all_events = cursor.fetchall()

            # Pobierz dane wszystkich użytkowników (wydział, przełożony, nazwa) w jednym zapytaniu
            users_query = """
            SELECT Uzytkownik, WydzialGrafik as Wydzial, PrzelozonyDane as Przelozony, UzytkownikDane
            FROM p_t_do_KonfiguracjaZatrudnienie
            WHERE Rok = ? AND Miesiac = ? AND Flaga = 1
            """
            cursor.execute(users_query, (year, month))
            users_data = cursor.fetchall()

            conn.close()

            # Przygotowanie mapy użytkowników - tylko raz
            self.user_info_map = {}
            for user_data in users_data:
                user_id, wydzial, przelozony, uzytkownik_dane = user_data
                self.user_info_map[user_id] = {
                    'wydzial': wydzial or 'Nieznany',
                    'przelozony': przelozony or 'Nieznany',
                    'uzytkownik_dane': uzytkownik_dane or f"{user_id}"
                }

            # Przetwórz zdarzenia i zapisz w buforze
            self.all_events_data = []
            for event_data in all_events:
                event_type, topic, name, event_user_id, event_date, time_from, time_to, status, event_id = event_data

                # Pobierz dane użytkownika (z przygotowanej wcześniej mapy)
                user_info = self.user_info_map.get(event_user_id, {
                    'wydzial': 'Nieznany',
                    'przelozony': 'Nieznany',
                    'uzytkownik_dane': f"{event_user_id}"
                })
                user_name = user_info['uzytkownik_dane']

                # Formatuj daty
                if event_date:
                    if isinstance(event_date, str):
                        date_obj = event_date.split(' ')[0]  # Pobierz tylko część daty (bez czasu)
                    else:
                        date_obj = event_date.strftime('%d.%m.%Y')

                    date_key = event_date  # Zachowaj oryginalną datę do filtrowania
                else:
                    # Jeśli brak daty, użyj pierwszego dnia miesiąca
                    date_obj = f"01.{month:02d}.{year}"
                    date_key = f"{year}-{month:02d}-01"

                # Formatuj czas
                time_from_obj = time_from.strftime('%H:%M') if time_from else "00:00"
                time_to_obj = time_to.strftime('%H:%M') if time_to else "00:00"

                self.all_events_data.append({
                    'type': event_type,
                    'topic': topic or '',
                    'name': name or '',
                    'user_id': event_user_id,
                    'user_name': user_name,
                    'date': date_obj,
                    'date_key': date_key,  # Do filtrowania po dacie
                    'time_from': time_from_obj,
                    'time_to': time_to_obj,
                    'status': status or 'Nieznany',
                    'id': event_id
                })

            # Po załadowaniu do bufora, załaduj zdarzenia dla bieżącego zaznaczenia (lub wszystkie)
            self.on_selection_changed()

        except Exception as e:
            # Pokaż komunikat błędu
            QMessageBox.critical(
                self,
                "Błąd",
                f"Wystąpił błąd podczas ładowania zdarzeń: {str(e)}",
                QMessageBox.StandardButton.Ok
            )
            self.all_events_data = []
            self.user_info_map = {}
            self.events_table.setRowCount(0)

    # Metoda do aktualizacji danych
    def update_data(self, year, month):
        """Aktualizuje dane dla wybranego roku i miesiąca"""
        self.year = year
        self.month = month

        print(f"Pobieranie danych dla {year}-{month}")

        # Wyczyść istniejące dane
        self.raw_data = []
        self.processed_data = {}
        self.all_events_data = []
        self.user_info_map = {}

        # Pokaż informację o ładowaniu
        self.table.clear()  # Wyczyść całą tabelę
        self.table.setRowCount(1)
        self.table.setColumnCount(1)  # Ustaw tylko jedną kolumnę na komunikat

        loading_item = QTableWidgetItem("Ładowanie danych...")
        loading_item.setTextAlignment(Qt.AlignCenter)
        loading_font = QFont()
        loading_font.setBold(True)
        loading_font.setPointSize(12)
        loading_item.setFont(loading_font)

        self.table.setItem(0, 0, loading_item)
        self.table.horizontalHeader().setVisible(False)  # Ukryj nagłówek na czas ładowania
        self.table.verticalHeader().setVisible(False)  # Ukryj numery wierszy na czas ładowania

        # Wyczyść tabelę zdarzeń
        self.events_table.setRowCount(0)

        # Użyj wątku do pobrania danych bez blokowania interfejsu
        self.data_thread = DataFetcherThread(year, month)
        self.data_thread.data_fetched.connect(self.on_data_fetched)
        self.data_thread.start()

        # Rozpocznij sprawdzanie nowych danych co 1 minutę
        self.setup_check_timer()

    def setup_check_timer(self):
        """Konfiguruje timer do sprawdzania nowych danych"""
        # Zatrzymaj istniejący timer jeśli działa
        if hasattr(self, 'check_timer') and self.check_timer.isActive():
            self.check_timer.stop()

        # Utwórz nowy timer
        self.check_timer = QTimer()
        self.check_timer.timeout.connect(self.check_for_new_data)
        self.check_timer.start(60000)  # 60 sekund = 1 minuta

    def refresh_data(self):
        """Odświeża dane i resetuje stan przycisku odświeżania"""
        # Resetuj stan przycisku
        self.refresh_button.setText("Odśwież dane")

        # Przywróć domyślny styl przycisku
        button_style = """
            background-color: #2c2c2c;
            color: white;
            border: 1px solid #3a3a3a;
            padding: 5px;
            border-radius: 3px;
        """ if self.is_dark_theme else """
            background-color: #e0e0e0;
            color: black;
            border: 1px solid #cccccc;
            padding: 5px;
            border-radius: 3px;
        """
        self.refresh_button.setStyleSheet(button_style)

        # Pobierz rok i miesiąc
        current_data = self.date_combo.currentData()
        if current_data:
            year, month = current_data

            # Pobierz dane na nowo
            self.update_data(year, month)

    def check_for_new_data(self):
        """Sprawdza czy są nowe dane w bazie danych"""
        try:
            # Pobierz najnowszą datę modyfikacji z bazy danych
            query = """
                SELECT MAX(DataModyfikacji) as DataModyfikacji FROM p_v_zz_GrafikiPracy
            """
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()
            cursor.execute(query)
            result = cursor.fetchone()
            conn.close()

            if result and result[0]:
                latest_modification = result[0]
                print(f"Ostatnia modyfikacja w bazie: {latest_modification}")

                # Jeśli to pierwszy raz, zapamiętaj datę i wyjdź
                if not hasattr(self, 'last_modification_date') or not self.last_modification_date:
                    self.last_modification_date = latest_modification
                    print("Zapamiętano początkową datę modyfikacji")
                    return False

                # Sprawdź czy są nowsze dane - porównaj daty jako string dla pewności
                latest_str = str(latest_modification)
                last_str = str(self.last_modification_date)

                if latest_str > last_str:
                    print(
                        f"Wykryto nowe dane! Poprzednia modyfikacja: {self.last_modification_date}, nowa: {latest_modification}")

                    # Aktualizuj ostatnią datę modyfikacji
                    self.last_modification_date = latest_modification

                    # Zmień tekst przycisku odświeżania
                    self.refresh_button.setText("Nowe dane!")

                    # Wyraźny styl przycisku z nowymi danymi
                    new_data_style = """
                        background-color: #f39c12; 
                        color: white;
                        font-weight: bold;
                        border: 2px solid #e67e22;
                        padding: 5px;
                        border-radius: 3px;
                    """
                    self.refresh_button.setStyleSheet(new_data_style)

                    # Zatrzymaj timer - nie musimy już sprawdzać, czekamy na akcję użytkownika
                    self.check_timer.stop()

                    return True
                else:
                    print("Brak nowych danych")

            return False

        except Exception as e:
            print(f"Błąd podczas sprawdzania nowych danych: {e}")
            return False

    def filter_data(self):
        start_time = time.time()
        # Aplikuj filtry do wyświetlanych danych tabeli grafiku
        self.update_filtered_table()

        # Wyczyść tabelę zdarzeń, gdy zmieniają się filtry
        self.events_data = []
        self.events_table.setRowCount(0)

        self.log_time("Filtrowanie danych", start_time)

    def clear_filters(self):
        # Wyczyść wszystkie filtry
        self.wydzial_list.clearSelection()
        self.przelozony_list.clearSelection()
        self.uzytkownik_list.clearSelection()

        # Wyczyść pola wyszukiwania
        self.wydzial_filter.clear()
        self.przelozony_filter.clear()
        self.uzytkownik_filter.clear()

        # Pokaż wszystkie elementy list
        for i in range(self.wydzial_list.count()):
            self.wydzial_list.item(i).setHidden(False)

        for i in range(self.przelozony_list.count()):
            self.przelozony_list.item(i).setHidden(False)

        for i in range(self.uzytkownik_list.count()):
            self.uzytkownik_list.item(i).setHidden(False)

        self.update_filtered_table()

    # Metody do filtrowania list
    def filter_wydzial_list(self, text):
        """Filtruje listę wydziałów na podstawie wpisanego tekstu"""
        text = text.lower()
        for i in range(self.wydzial_list.count()):
            item = self.wydzial_list.item(i)
            if text == "" or text in item.text().lower():
                item.setHidden(False)
            else:
                item.setHidden(True)

    def filter_przelozony_list(self, text):
        """Filtruje listę przełożonych na podstawie wpisanego tekstu"""
        text = text.lower()
        for i in range(self.przelozony_list.count()):
            item = self.przelozony_list.item(i)
            if text == "" or text in item.text().lower():
                item.setHidden(False)
            else:
                item.setHidden(True)

    def filter_uzytkownik_list(self, text):
        """Filtruje listę użytkowników na podstawie wpisanego tekstu"""
        text = text.lower()
        for i in range(self.uzytkownik_list.count()):
            item = self.uzytkownik_list.item(i)
            if text == "" or text in item.text().lower():
                item.setHidden(False)
            else:
                item.setHidden(True)

    def update_filtered_table(self):
        # Filtrowanie danych na podstawie wybranych filtrów
        selected_wydzialy = self.get_selected_items(self.wydzial_list)
        selected_przelozeni = self.get_selected_items(self.przelozony_list)
        selected_uzytkownicy = self.get_selected_items(self.uzytkownik_list)

        # Określenie widocznych wierszy
        self.visible_rows = []
        for i, key in enumerate(self.processed_data.keys()):
            wydzial, przelozony, uzytkownik_dane, uzytkownik = key
            if (not selected_wydzialy or wydzial in selected_wydzialy) and \
                    (not selected_przelozeni or przelozony in selected_przelozeni) and \
                    (not selected_uzytkownicy or str(uzytkownik_dane) in selected_uzytkownicy):
                self.visible_rows.append(i)

        # Aktualizacja tabeli z uwzględnieniem filtrów
        self.update_table_content()

    # Metoda do obsługi danych zwróconych przez wątek
    def on_data_fetched(self, data):
        try:
            if not data or len(data) < 3:
                QMessageBox.critical(
                    self,
                    "Błąd",
                    "Nie udało się pobrać danych. Proszę spróbować ponownie.",
                    QMessageBox.StandardButton.Ok
                )
                return

            schedule_data, events_data, users_data = data

            # Przywróć tylko nagłówek poziomy
            self.table.horizontalHeader().setVisible(True)

            # Ukryj nagłówek pionowy (numery wierszy)
            self.table.verticalHeader().setVisible(False)

            # Przetwarzanie danych grafiku
            process_start = time.time()
            try:
                self.raw_data = schedule_data
                self.process_data(schedule_data)
                process_end = self.log_time("Przetwarzanie grafiku", process_start)
            except Exception as e:
                print(f"Błąd podczas przetwarzania grafiku: {str(e)}")
                process_end = time.time()
                # Kontynuuj mimo błędu

            # Przetwarzanie danych użytkowników
            users_start = time.time()
            try:
                self.user_info_map = {}
                for user_data in users_data:
                    if len(user_data) >= 4:  # Sprawdź czy dane są kompletne
                        user_id, wydzial, przelozony, uzytkownik_dane = user_data
                        self.user_info_map[user_id] = {
                            'wydzial': wydzial or 'Nieznany',
                            'przelozony': przelozony or 'Nieznany',
                            'uzytkownik_dane': uzytkownik_dane or f"{user_id}"
                        }
                users_end = self.log_time("Przetwarzanie użytkowników", users_start)
            except Exception as e:
                print(f"Błąd podczas przetwarzania użytkowników: {str(e)}")
                users_end = time.time()
                # Kontynuuj mimo błędu

            # Przetwarzanie zdarzeń - ta część może powodować problemy
            events_start = time.time()
            try:
                self.all_events_data = []
                if events_data:
                    for event_data in events_data:
                        try:
                            if len(event_data) >= 9:  # Sprawdź czy dane są kompletne
                                event_type, topic, name, event_user_id, event_date, time_from, time_to, status, event_id = event_data

                                # Pobierz dane użytkownika - bezpiecznie
                                user_info = self.user_info_map.get(event_user_id, {
                                    'wydzial': 'Nieznany',
                                    'przelozony': 'Nieznany',
                                    'uzytkownik_dane': f"{event_user_id}"
                                })
                                user_name = user_info.get('uzytkownik_dane', f"{event_user_id}")

                                # Bezpieczne formatowanie dat
                                date_obj = "01.01.2025"  # Wartość domyślna
                                date_key = event_date  # Zachowaj oryginalną datę

                                if event_date:
                                    try:
                                        if isinstance(event_date, str):
                                            date_parts = event_date.split(' ')[0].split('-')
                                            if len(date_parts) >= 3:
                                                date_obj = f"{date_parts[2]}.{date_parts[1]}.{date_parts[0]}"
                                        else:
                                            date_obj = event_date.strftime('%d.%m.%Y')
                                    except:
                                        # W przypadku problemu z formatowaniem daty
                                        pass

                                # Bezpieczne formatowanie czasu
                                time_from_obj = "00:00"
                                time_to_obj = "00:00"

                                try:
                                    if time_from:
                                        time_from_obj = time_from.strftime('%H:%M')
                                except:
                                    pass

                                try:
                                    if time_to:
                                        time_to_obj = time_to.strftime('%H:%M')
                                except:
                                    pass

                                self.all_events_data.append({
                                    'type': event_type or 'Nieznany',
                                    'topic': topic or '',
                                    'name': name or '',
                                    'user_id': event_user_id,
                                    'user_name': user_name,
                                    'date': date_obj,
                                    'date_key': date_key,
                                    'time_from': time_from_obj,
                                    'time_to': time_to_obj,
                                    'status': status or 'Nieznany',
                                    'id': event_id
                                })
                        except Exception as event_error:
                            print(f"Błąd podczas przetwarzania zdarzenia: {str(event_error)}")
                            continue  # Przejdź do następnego zdarzenia

                events_end = self.log_time(f"Przetwarzanie {len(self.all_events_data)} zdarzeń", events_start)
            except Exception as e:
                print(f"Błąd podczas przetwarzania zdarzeń: {str(e)}")
                events_end = time.time()
                # Kontynuuj mimo błędu - już mamy grafik

            # Aktualizacja interfejsu użytkownika - każda operacja zabezpieczona oddzielnie
            # Aktualizacja interfejsu
            ui_start = time.time()

            # Aktualizacja filtrów
            filters_start = time.time()
            try:
                self.update_filters()
                filters_end = self.log_time("Aktualizacja filtrów", filters_start)
            except Exception as e:
                print(f"Błąd podczas aktualizacji filtrów: {str(e)}")
                filters_end = time.time()

            # Aktualizacja tabeli
            table_start = time.time()
            try:
                self.update_filtered_table()
                table_end = self.log_time("Aktualizacja tabeli grafiku", table_start)
            except Exception as e:
                print(f"Błąd podczas aktualizacji tabeli: {str(e)}")
                table_end = time.time()

            # Aktualizacja dat
            dates_start = time.time()
            try:
                self.update_filter_dates()
                dates_end = self.log_time("Aktualizacja dat", dates_start)
            except Exception as e:
                print(f"Błąd podczas aktualizacji dat: {str(e)}")
                dates_end = time.time()

            # Aktualizacja zdarzeń
            selection_start = time.time()
            try:
                # To może być problematyczne - obsługujemy tylko jeśli zainicjalizowano zdarzenia
                if hasattr(self, 'all_events_data') and self.all_events_data:
                    self.on_selection_changed()
                selection_end = self.log_time("Aktualizacja zdarzeń", selection_start)
            except Exception as e:
                print(f"Błąd podczas aktualizacji zaznaczenia: {str(e)}")
                selection_end = time.time()

            self.log_time("Całkowity czas aktualizacji UI", ui_start)

            # Na końcu metody również upewnij się, że nagłówek pionowy jest ukryty
            self.table.verticalHeader().setVisible(False)

        except Exception as e:

            print(f"Błąd podczas przetwarzania danych: {str(e)}")

            QMessageBox.critical(

                self,

                "Błąd",

                f"Wystąpił błąd podczas przetwarzania danych: {str(e)}",

                QMessageBox.StandardButton.Ok

            )

        self.log_time("CAŁKOWITY CZAS PRZETWARZANIA DANYCH", start_time)

    def handle_data_error(self, message):
        """Bezpieczna obsługa błędów"""
        try:
            QMessageBox.critical(
                self,
                "Błąd",
                message,
                QMessageBox.StandardButton.Ok
            )
        except:
            print(f"Nie można wyświetlić komunikatu błędu: {message}")

    def get_selected_items(self, list_widget):
        """Zwraca teksty zaznaczonych elementów z listy"""
        selected = []
        for i in range(list_widget.count()):
            item = list_widget.item(i)
            if item.isSelected():
                selected.append(item.text())
        return selected

    def update_filters(self):
        # Aktualizacja filtrów na podstawie pobranych danych
        # Zapamiętaj bieżące zaznaczenia
        selected_wydzialy = self.get_selected_items(self.wydzial_list)
        selected_przelozeni = self.get_selected_items(self.przelozony_list)
        selected_uzytkownicy = self.get_selected_items(self.uzytkownik_list)

        # Wydziały
        self.wydzial_list.clear()
        wydzialy = set()
        for key in self.processed_data.keys():
            wydzial = key[0]
            wydzialy.add(wydzial)

        for wydzial in sorted(wydzialy):
            item = QListWidgetItem(wydzial)
            self.wydzial_list.addItem(item)
            # Przywróć zaznaczenie jeśli było
            if wydzial in selected_wydzialy:
                item.setSelected(True)

        # Aktualizacja przełożonych
        self.update_przelozony_filter(selected_przelozeni)

        # Aktualizacja użytkowników
        self.update_uzytkownik_filter(selected_uzytkownicy)

    def update_przelozony_filter(self, selected_przelozeni=None):
        # Aktualizacja listy przełożonych na podstawie wybranych wydziałów
        if selected_przelozeni is None:
            selected_przelozeni = []

        self.przelozony_list.clear()

        selected_wydzialy = self.get_selected_items(self.wydzial_list)

        przelozeni = set()
        for key in self.processed_data.keys():
            wydzial, przelozony, _, _ = key
            if not selected_wydzialy or wydzial in selected_wydzialy:
                przelozeni.add(przelozony)

        for przelozony in sorted(przelozeni):
            item = QListWidgetItem(przelozony)
            self.przelozony_list.addItem(item)
            # Przywróć zaznaczenie jeśli było
            if przelozony in selected_przelozeni:
                item.setSelected(True)

    def update_uzytkownik_filter(self, selected_uzytkownicy=None):
        # Aktualizacja listy użytkowników na podstawie wybranych wydziałów i przełożonych
        if selected_uzytkownicy is None:
            selected_uzytkownicy = []

        self.uzytkownik_list.clear()

        selected_wydzialy = self.get_selected_items(self.wydzial_list)
        selected_przelozeni = self.get_selected_items(self.przelozony_list)

        uzytkownicy_data = []
        for key in self.processed_data.keys():
            wydzial, przelozony, uzytkownik_dane, uzytkownik = key
            if (not selected_wydzialy or wydzial in selected_wydzialy) and \
                    (not selected_przelozeni or przelozony in selected_przelozeni):
                uzytkownicy_data.append(uzytkownik_dane)

        for uzytkownik in sorted(uzytkownicy_data):
            item = QListWidgetItem(str(uzytkownik))
            self.uzytkownik_list.addItem(item)
            # Przywróć zaznaczenie jeśli było
            if str(uzytkownik) in selected_uzytkownicy:
                item.setSelected(True)

    def process_data(self, data):
        # Przetwarzamy dane do struktury:
        # {(wydzial, przelozony, uzytkownik_dane, uzytkownik): {
        #     'days': {1: {'symbol': 'xxx', 'hours': 8, 'id': 123}, ...},
        #     'total_hours': suma_godzin
        # }}

        self.processed_data = {}

        for row in data:
            if len(row) >= 8:  # Upewniamy się, że mamy wszystkie potrzebne dane
                wydzial, przelozony, uzytkownik_dane, uzytkownik, data_str, symbol, godziny_pracy, id_wpisu = row

                # Klucz dla grupy (wydział, przełożony, użytkownik)
                key = (wydzial, przelozony, uzytkownik_dane, uzytkownik)

                # Jeśli nie ma jeszcze wpisu dla tego klucza, utwórz go
                if key not in self.processed_data:
                    self.processed_data[key] = {'days': {}, 'total_hours': 0}

                # Jeśli data_str nie jest None, dodaj symbol i godziny dla odpowiedniego dnia
                if data_str:
                    day = int(data_str.split('-')[2])  # Pobierz dzień z daty w formacie 'YYYY-MM-DD'
                    self.processed_data[key]['days'][day] = {
                        'symbol': symbol,
                        'hours': godziny_pracy if godziny_pracy is not None else 0,
                        'id': id_wpisu
                    }

                    # Sumuj godziny pracy
                    if godziny_pracy is not None:
                        self.processed_data[key]['total_hours'] += godziny_pracy

    def update_table_content(self):
        start_time = time.time()

        # Pobierz aktualny rok i miesiąc
        current_data = self.date_combo.currentData()
        if not current_data:
            return

        year, month_idx = current_data

        # Określ liczbę dni w miesiącu
        if month_idx in [4, 6, 9, 11]:
            days_in_month = 30
        elif month_idx == 2:  # Luty
            if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0):  # Rok przestępny
                days_in_month = 29
            else:
                days_in_month = 28
        else:
            days_in_month = 31

        # Konfiguracja tabeli
        self.table.clear()

        # Ustawienie liczby kolumn (Wydział, Przełożony, Pracownik, dni miesiąca, Suma RBH)
        self.table.setColumnCount(3 + days_in_month + 1)

        # Ustawienie nagłówków kolumn
        headers = ["Wydział", "Przełożony", "Pracownik"]
        for day in range(1, days_in_month + 1):
            # Ustal dzień tygodnia
            date = QDate(year, month_idx, day)
            day_of_week = date.dayOfWeek()  # 1=Pon, 2=Wt, ..., 7=Nie

            # Ustal etykietę dnia tygodnia
            day_labels = ["Pon", "Wt", "Śr", "Czw", "Pt", "Sob", "Nie"]
            day_label = day_labels[day_of_week - 1]

            headers.append(f"{day}\n{day_label}")

        # Dodaj nagłówek suma RBH
        headers.append("Suma RBH")

        self.table.setHorizontalHeaderLabels(headers)

        # Znajdź kolumny z weekendami i ustaw je w niestandardowym nagłówku
        weekend_columns = []
        for col in range(3, 3 + days_in_month):
            day = col - 2
            date = QDate(year, month_idx, day)
            day_of_week = date.dayOfWeek()

            # Jeśli to weekend (sobota=6, niedziela=7)
            if day_of_week >= 6:
                weekend_columns.append(col)
                # Pobierz istniejący element nagłówka
                header_item = self.table.horizontalHeaderItem(col)
                if header_item:
                    # Bezpośrednio ustaw kolor czcionki
                    if self.is_dark_theme:
                        header_item.setForeground(QColor(255, 99, 71))  # Tomato red dla ciemnego motywu
                    else:
                        header_item.setForeground(QColor(220, 20, 60))  # Crimson dla jasnego motywu

        # Ustaw kolumny weekendowe w niestandardowym nagłówku
        header = self.table.horizontalHeader()
        if isinstance(header, WeekendAwareHeaderView):
            header.set_weekend_columns(weekend_columns, self.is_dark_theme)
            # Ważne - wymuś odświeżenie nagłówka
            header.viewport().update()

        # Ustaw szerokość kolumn
        self.table.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeToContents)  # Wydział
        self.table.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeToContents)  # Przełożony
        self.table.horizontalHeader().setSectionResizeMode(2, QHeaderView.ResizeToContents)  # Pracownik

        # Dla dni miesiąca - stała szerokość
        for i in range(3, 3 + days_in_month):
            self.table.horizontalHeader().setSectionResizeMode(i, QHeaderView.Interactive)
            self.table.setColumnWidth(i, 50)  # Szerokość kolumn z dniami

        # Kolumna z sumą RBH
        suma_rbh_col = 3 + days_in_month
        self.table.horizontalHeader().setSectionResizeMode(suma_rbh_col, QHeaderView.ResizeToContents)

        # Wypełnianie tabeli tylko widocznymi wierszami
        row_idx = 0
        self.table.setRowCount(len(self.visible_rows))

        for row_idx, orig_idx in enumerate(self.visible_rows):
            key = list(self.processed_data.keys())[orig_idx]
            data = self.processed_data[key]
            wydzial, przelozony, uzytkownik_dane, uzytkownik = key
            day_data = data['days']
            total_hours = data['total_hours']

            # Podstawowe informacje
            self.table.setItem(row_idx, 0, QTableWidgetItem(wydzial))
            self.table.setItem(row_idx, 1, QTableWidgetItem(przelozony))
            self.table.setItem(row_idx, 2, QTableWidgetItem(uzytkownik_dane))

            # Symbole grafiku dla poszczególnych dni
            for day in range(1, days_in_month + 1):
                if day in day_data:
                    symbol = day_data[day]['symbol']
                    item = QTableWidgetItem(symbol)

                    # Kolorowanie specjalnych symboli
                    if symbol and "NN" in symbol:
                        item.setBackground(QColor(255, 100, 100))  # Czerwony dla NN
                    elif symbol and "U" in symbol:
                        item.setBackground(QColor(255, 180, 0))  # Pomarańczowy dla U

                    self.table.setItem(row_idx, 2 + day, item)
                else:
                    # Pusta komórka
                    item = QTableWidgetItem("")
                    self.table.setItem(row_idx, 2 + day, item)

            # Suma RBH
            self.table.setItem(row_idx, suma_rbh_col, QTableWidgetItem(str(total_hours)))

        # Dopasuj wysokość wierszy
        self.table.resizeRowsToContents()

        self.log_time("Aktualizacja zawartości tabeli grafiku", start_time)

        # Na końcu metody
        self.table.verticalHeader().setVisible(False)

    def update_table(self):
        # Inicjalizacja widocznych wierszy - wszystkie wiersze są widoczne
        self.visible_rows = list(range(len(self.processed_data)))
        self.update_table_content()

    def on_selection_changed(self):
        start_time = time.time()
        selected_ranges = self.table.selectedRanges()

        # Pobierz aktualny rok i miesiąc
        current_data = self.date_combo.currentData()
        if not current_data:
            return

        year, month_idx = current_data

        # Określ liczbę dni w miesiącu
        if month_idx in [4, 6, 9, 11]:
            days_in_month = 30
        elif month_idx == 2:
            if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0):
                days_in_month = 29
            else:
                days_in_month = 28
        else:
            days_in_month = 31

        # Zbierz informacje o wszystkich zaznaczonych komórkach
        selected_cells = []

        # Tylko jeśli są zaznaczone komórki
        if selected_ranges:
            print(f"Liczba zaznaczonych zakresów: {len(selected_ranges)}")

            for i, range_item in enumerate(selected_ranges):
                print(
                    f"Zakres {i + 1}: wiersze {range_item.topRow()}-{range_item.bottomRow()}, kolumny {range_item.leftColumn()}-{range_item.rightColumn()}")

                for table_row in range(range_item.topRow(), range_item.bottomRow() + 1):
                    for col in range(range_item.leftColumn(), range_item.rightColumn() + 1):
                        # Sprawdź czy to komórka z grafikiem (kolumny od 3 do 3+days_in_month-1)
                        if col >= 3 and col < 3 + days_in_month:
                            # Przekształć indeks wiersza tabeli na indeks w danych
                            if table_row < len(self.visible_rows):
                                data_row = self.visible_rows[table_row]
                                if data_row < len(self.processed_data):
                                    # Pobierz klucz dla tego wiersza
                                    key = list(self.processed_data.keys())[data_row]
                                    wydzial, przelozony, uzytkownik_dane, uzytkownik = key

                                    # Pobierz dzień z kolumny
                                    day = col - 2

                                    # Utworzenie daty dla debugowania
                                    date_str = QDate(year, month_idx, day).toString('yyyy-MM-dd')
                                    print(
                                        f"Analizuję komórkę: wiersz={table_row}, kolumna={col}, użytkownik={uzytkownik}, dzień={day}, data={date_str}")

                                    # Pobierz dane dla tego dnia jeśli istnieją
                                    day_data = self.processed_data[key]['days'].get(day)

                                    # KLUCZOWA ZMIANA: Zawsze dodaj komórkę, nawet jeśli brak danych w processed_data
                                    # Ta zmiana pozwoli znaleźć zdarzenia nawet dla dni, które nie mają jeszcze zapisanych danych w grafiku
                                    selected_cells.append({
                                        'wydzial': wydzial,
                                        'przelozony': przelozony,
                                        'uzytkownik_dane': uzytkownik_dane,
                                        'uzytkownik_id': uzytkownik,
                                        'day': day,
                                        'symbol': day_data.get('symbol') if day_data else None,
                                        'hours': day_data.get('hours') if day_data else None,
                                        'id': day_data.get('id') if day_data else None
                                    })

                                    if day_data:
                                        print(f"Dodano komórkę do zaznaczenia: użytkownik={uzytkownik}, dzień={day}")
                                    else:
                                        print(
                                            f"Dodano komórkę (bez danych w grafiku): użytkownik={uzytkownik}, dzień={day}")

            print(f"Zaznaczono {len(selected_cells)} komórek grafiku")

            # Dodajmy również szczegółowe debugowanie par
            user_date_pairs = set()
            for cell in selected_cells:
                user_id = cell['uzytkownik_id']
                day = cell['day']
                date_str = QDate(year, month_idx, day).toString('yyyy-MM-dd')
                user_date_pairs.add((user_id, date_str))

            print(f"Utworzono pary (użytkownik, data):")
            for pair in user_date_pairs:
                print(f"  - Użytkownik: {pair[0]}, Data: {pair[1]}")

            # Jeśli są zaznaczone komórki - ładuj dla nich zdarzenia
            if selected_cells:
                self.load_events_for_selection(selected_cells)
        else:
            print("Brak zaznaczenia - czyszczę tabelę zdarzeń")
            # Gdy nie ma zaznaczenia - wyczyść tabelę zdarzeń
            self.events_data = []
            self.events_table.setRowCount(0)

        self.log_time("Obsługa zmiany zaznaczenia", start_time)

    # Nowa metoda do ładowania wszystkich zdarzeń dla wybranego miesiąca
    def load_all_events_for_month(self, year, month):
        """Ładuje wszystkie zdarzenia dla wybranego miesiąca z bufora z uwzględnieniem filtrów"""
        start_time = time.time()

        # Pobierz wybrane filtry
        selected_wydzialy = self.get_selected_items(self.wydzial_list)
        selected_przelozeni = self.get_selected_items(self.przelozony_list)
        selected_uzytkownicy = self.get_selected_items(self.uzytkownik_list)

        print(
            f"Filtry: Wydziały({len(selected_wydzialy)}), Przełożeni({len(selected_przelozeni)}), Użytkownicy({len(selected_uzytkownicy)})")

        # Czyść poprzednie dane
        self.events_data = []

        # Filtruj zdarzenia z bufora
        for event in self.all_events_data:
            event_user_id = event['user_id']

            # Pobierz dane użytkownika z mapy
            user_info = self.user_info_map.get(event_user_id, {
                'wydzial': 'Nieznany',
                'przelozony': 'Nieznany',
                'uzytkownik_dane': f"{event_user_id}"
            })
            event_wydzial = user_info['wydzial']
            event_przelozony = user_info['przelozony']

            # Zastosuj filtry wydziału, przełożonego i użytkownika
            if selected_wydzialy and event_wydzial not in selected_wydzialy:
                continue
            if selected_przelozeni and event_przelozony not in selected_przelozeni:
                continue
            if selected_uzytkownicy and str(event_user_id) not in selected_uzytkownicy:
                continue

            self.events_data.append(event)

        print(f"Znaleziono {len(self.events_data)} zdarzeń dla miesiąca {month}/{year} z zastosowaniem filtrów")

        # Aktualizuj tabelę zdarzeń
        self.filter_events_table()

        self.log_time(f"Ładowanie wszystkich zdarzeń dla miesiąca {month}/{year}", start_time)

    def load_events_for_selection(self, selected_cells):
        """Ładuje zdarzenia (spotkania, szkolenia, nadgodziny) dla wybranych komórek w grafiku z bufora"""
        start_time = time.time()

        # Pobierz unikalne pary (użytkownik_id, data) z zaznaczonych komórek
        user_date_pairs = set()
        current_data = self.date_combo.currentData()
        if not current_data:
            self.events_data = []
            self.events_table.setRowCount(0)
            return

        year, month = current_data

        for cell in selected_cells:
            user_id = cell['uzytkownik_id']
            day = cell['day']
            date_str = QDate(year, month, day).toString('yyyy-MM-dd')
            user_date_pairs.add((user_id, date_str))

        print(f"Szukam zdarzeń dla {len(user_date_pairs)} par (użytkownik, data)")

        # Czyść poprzednie dane
        self.events_data = []
        matched_pairs = set()  # Dla śledzenia znalezionych par

        # Filtruj zdarzenia z bufora
        for event in self.all_events_data:
            event_user_id = event['user_id']
            event_date = event['date_key']

            # Konwertuj datę do standardowego formatu string
            if hasattr(event_date, 'strftime'):  # Sprawdź czy obiekt ma metodę strftime (datetime/date)
                event_date_str = event_date.strftime('%Y-%m-%d')
            else:
                # Jeśli to już string, upewnij się, że ma właściwy format
                event_date_str = str(event_date)
                # Jeśli data zawiera czas, usuń go
                if ' ' in event_date_str:
                    event_date_str = event_date_str.split(' ')[0]

            # Sprawdź, czy zdarzenie pasuje do zaznaczonych komórek (użytkownik i data)
            pair = (event_user_id, event_date_str)
            if pair in user_date_pairs:
                matched_pairs.add(pair)
                self.events_data.append(event)
                print(f"Dodano zdarzenie: typu={event['type']}, użytkownik={event_user_id}, data={event_date_str}")

        # Wyświetl, których par nie znaleziono
        if len(matched_pairs) < len(user_date_pairs):
            unmatched = user_date_pairs - matched_pairs
            print(f"Nie znaleziono zdarzeń dla {len(unmatched)} par:")
            for pair in unmatched:
                print(f"  - Użytkownik: {pair[0]}, Data: {pair[1]}")

        print(f"Znaleziono {len(self.events_data)} zdarzeń dla zaznaczonych komórek")

        # Aktualizuj tabelę zdarzeń
        self.filter_events_table()


        self.log_time(f"Ładowanie zdarzeń dla {len(selected_cells)} komórek", start_time)

    def filter_events_by_date_range(self):
        """
        Filtruje zdarzenia na podstawie wybranego zakresu dat.
        """
        # Pobierz daty z kontrolek i przekonwertuj je na string w formacie 'YYYY-MM-DD'
        date_from = self.date_from.date().toString('yyyy-MM-dd')
        date_to = self.date_to.date().toString('yyyy-MM-dd')

        # Pobierz filtry tematu i nazwy
        topic_filter = self.topic_filter.text().lower()
        name_filter = self.name_filter.text().lower()

        # Pobierz wybrane filtry z list
        selected_departments = self.get_selected_items(self.wydzial_list)
        selected_supervisors = self.get_selected_items(self.przelozony_list)
        selected_users = self.get_selected_items(self.uzytkownik_list)

        # Przefiltruj wydarzenia
        filtered_events = []
        for event in self.all_events_data:
            # Filtrowanie po dacie - porównuj stringi w tym samym formacie
            event_date = event['date_key']
            if isinstance(event_date, datetime) or isinstance(event_date, date):
                event_date_str = event_date.strftime('%Y-%m-%d')
            else:
                # Jeśli to już string, upewnij się że ma właściwy format
                event_date_str = event_date

            if date_from and event_date_str < date_from:
                continue
            if date_to and event_date_str > date_to:
                continue

            # Filtrowanie po temacie
            if topic_filter and topic_filter.lower() not in event['topic'].lower():
                continue

            # Filtrowanie po nazwie
            if name_filter and name_filter.lower() not in event['name'].lower():
                continue

            # Filtrowanie po typie wydarzenia
            if not self.meetings_checkbox.isChecked() and event['type'] == 'Spotkanie':
                continue
            if not self.trainings_checkbox.isChecked() and event['type'] == 'Szkolenie':
                continue
            if not self.overtime_checkbox.isChecked() and event['type'] == 'Nadgodziny':
                continue

            # Pobierz dane użytkownika
            event_user_id = event['user_id']
            user_info = self.user_info_map.get(event_user_id, {
                'wydzial': 'Nieznany',
                'przelozony': 'Nieznany',
                'uzytkownik_dane': f"{event_user_id}"
            })
            event_wydzial = user_info['wydzial']
            event_przelozony = user_info['przelozony']

            # Filtrowanie po wydziale
            if selected_departments and event_wydzial not in selected_departments:
                continue

            # Filtrowanie po przełożonym
            if selected_supervisors and event_przelozony not in selected_supervisors:
                continue

            # Filtrowanie po użytkowniku
            if selected_users and str(event_user_id) not in selected_users:
                continue

            filtered_events.append(event)

        # Aktualizuj tabelę zdarzeń
        self.events_data = filtered_events
        self.update_events_table(filtered_events)

        # Pokaż komunikat
        QMessageBox.information(
            self,
            "Informacja",
            f"Znaleziono {len(filtered_events)} zdarzeń w wybranym zakresie dat.",
            QMessageBox.Ok
        )

    def filter_events_table(self):
        """Filtruje tabelę zdarzeń na podstawie zaznaczonych filtrów"""
        try:
            # Pobierz zaznaczone typy zdarzeń
            show_meetings = self.meetings_checkbox.isChecked()
            show_trainings = self.trainings_checkbox.isChecked()
            show_overtime = self.overtime_checkbox.isChecked()

            # Sprawdź, czy self.events_data istnieje i jest listą
            if not hasattr(self, 'events_data') or not isinstance(self.events_data, list):
                print("Brak danych zdarzeń do filtrowania")
                self.events_table.setRowCount(0)  # Wyczyść tabelę
                return

            # Przefiltruj dane
            filtered_data = []
            for event in self.events_data:
                if not isinstance(event, dict):
                    print(f"Nieprawidłowy format zdarzenia: {event}")
                    continue

                # Sprawdź typ zdarzenia
                event_type = event.get('type', '')
                if (event_type == 'Spotkanie' and not show_meetings or
                        event_type == 'Szkolenie' and not show_trainings or
                        event_type == 'Nadgodziny' and not show_overtime):
                    continue

                # Sprawdź filtry tekstu (temat i nazwa)
                if hasattr(self, 'topic_filter') and self.topic_filter.text():
                    topic_filter = self.topic_filter.text().lower()
                    event_topic = str(event.get('topic', '')).lower()
                    if topic_filter not in event_topic:
                        continue

                if hasattr(self, 'name_filter') and self.name_filter.text():
                    name_filter = self.name_filter.text().lower()
                    event_name = str(event.get('name', '')).lower()
                    if name_filter not in event_name:
                        continue

                filtered_data.append(event)

            # Aktualizuj tabelę
            self.update_events_table(filtered_data)
        except Exception as e:
            print(f"Błąd podczas filtrowania zdarzeń: {str(e)}")
            # Wyczyść tabelę w przypadku błędu
            self.events_table.setRowCount(0)

    def update_events_table(self, filtered_data):
        """
        Aktualizuje tabelę zdarzeń w zoptymalizowany sposób - przygotowuje wszystkie
        dane przed ich umieszczeniem w tabeli.
        """
        start_time = time.time()

        # Ustawienie rozmiaru tabeli - tylko raz!
        self.events_table.setRowCount(len(filtered_data))

        # Listy do przechowywania obiektów do umieszczenia w tabeli
        table_items = []
        buttons_data = []

        # Przygotuj wszystkie elementy tabeli w pamięci
        for row, event in enumerate(filtered_data):
            # Typ
            type_item = QTableWidgetItem(event['type'])
            if event['type'] == 'Spotkanie':
                type_item.setBackground(QColor(100, 149, 237))  # Cornflower Blue
            elif event['type'] == 'Szkolenie':
                type_item.setBackground(QColor(144, 238, 144))  # Light Green
            elif event['type'] == 'Nadgodziny':
                type_item.setBackground(QColor(255, 165, 0))  # Orange
            table_items.append((row, 0, type_item))

            # Pozostałe kolumny - tekstowe
            table_items.append((row, 1, QTableWidgetItem(str(event.get('topic', '')))))
            table_items.append((row, 2, QTableWidgetItem(str(event.get('name', '')))))
            table_items.append((row, 3, QTableWidgetItem(str(event.get('user_name', '')))))
            table_items.append((row, 4, QTableWidgetItem(str(event.get('date', '')))))
            table_items.append((row, 5, QTableWidgetItem(str(event.get('time_from', '')))))
            table_items.append((row, 6, QTableWidgetItem(str(event.get('time_to', '')))))
            table_items.append((row, 7, QTableWidgetItem(str(event.get('status', '')))))

            # Zapamiętaj dane przycisku do późniejszego utworzenia
            buttons_data.append((row, event.get('id', 0), event.get('type', '')))

        # Umieść wszystkie przygotowane elementy w tabeli - szybsza operacja
        for row, col, item in table_items:
            self.events_table.setItem(row, col, item)

        # Teraz utwórz i dodaj przyciski
        for row, event_id, event_type in buttons_data:
            delete_button = QPushButton("Usuń")
            delete_button.setStyleSheet("""
                background-color: #e74c3c;
                color: white;
                border-radius: 3px;
                padding: 3px;
                font-weight: bold;
            """)
            delete_button.clicked.connect(lambda checked, eid=event_id, etype=event_type:
                                          self.delete_event(eid, etype))
            self.events_table.setCellWidget(row, 8, delete_button)

        # Dopasuj wysokość wierszy tylko raz na końcu
        self.events_table.resizeRowsToContents()

        self.log_time(f"Aktualizacja tabeli zdarzeń ({len(filtered_data)} wierszy)", start_time)


    def delete_event(self, event_id, event_type):
        """Usuwa zdarzenie z bazy danych i aktualizuje bufor"""
        # Pokaż komunikat potwierdzenia
        reply = QMessageBox.question(
            self,
            "Potwierdzenie",
            f"Czy na pewno chcesz usunąć {event_type.lower()} o ID {event_id}?",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.No
        )

        if reply != QMessageBox.StandardButton.Yes:
            return

        table_name = ""
        if event_type == "Spotkanie":
            table_name = "p_v_zz_Spotkania"
        elif event_type == "Szkolenie":
            table_name = "p_v_zz_Szkolenia"
        elif event_type == "Nadgodziny":
            table_name = "p_t_zz_Nadgodziny"

        if not table_name:
            QMessageBox.warning(
                self,
                "Błąd",
                "Nieprawidłowy typ zdarzenia.",
                QMessageBox.StandardButton.Ok
            )
            return

        try:
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()

            # Usuń rekord z bazy danych
            query = f"DELETE FROM {table_name} WHERE Id = ?"
            cursor.execute(query, (event_id,))
            conn.commit()
            conn.close()

            # Usuń zdarzenie z bufora
            self.all_events_data = [event for event in self.all_events_data if event['id'] != event_id]

            # Odśwież tabelę zdarzeń
            selected_ranges = self.table.selectedRanges()
            if selected_ranges:
                selected_cells = []
                for range_item in selected_ranges:
                    for table_row in range(range_item.topRow(), range_item.bottomRow() + 1):
                        for col in range(range_item.leftColumn(), range_item.rightColumn() + 1):
                            current_data = self.date_combo.currentData()
                            if not current_data:
                                continue
                            year, month_idx = current_data

                            if month_idx in [4, 6, 9, 11]:
                                days_in_month = 30
                            elif month_idx == 2:
                                if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0):
                                    days_in_month = 29
                                else:
                                    days_in_month = 28
                            else:
                                days_in_month = 31

                            if col >= 3 and col < 3 + days_in_month:
                                if table_row < len(self.visible_rows):
                                    data_row = self.visible_rows[table_row]
                                    if data_row < len(self.processed_data):
                                        key = list(self.processed_data.keys())[data_row]
                                        wydzial, przelozony, uzytkownik_dane, uzytkownik = key
                                        day = col - 2
                                        day_data = self.processed_data[key]['days'].get(day)
                                        if day_data:
                                            selected_cells.append({
                                                'wydzial': wydzial,
                                                'przelozony': przelozony,
                                                'uzytkownik_dane': uzytkownik_dane,
                                                'uzytkownik_id': uzytkownik,
                                                'day': day,
                                                'symbol': day_data.get('symbol'),
                                                'hours': day_data.get('hours'),
                                                'id': day_data.get('id')
                                            })

                self.load_events_for_selection(selected_cells)
            else:
                current_data = self.date_combo.currentData()
                if current_data:
                    year, month = current_data
                    self.load_all_events_for_month(year, month)

            # Pokaż komunikat sukcesu
            QMessageBox.information(
                self,
                "Sukces",
                f"{event_type} o ID {event_id} zostało pomyślnie usunięte.",
                QMessageBox.StandardButton.Ok
            )

        except Exception as e:
            QMessageBox.critical(
                self,
                "Błąd",
                f"Wystąpił błąd podczas usuwania zdarzenia: {str(e)}",
                QMessageBox.StandardButton.Ok
            )

    def show_theme_settings(self):
        """Pokazuje okno dialogowe z ustawieniami motywu"""
        theme = "dark" if self.is_dark_theme else "light"
        dialog = ThemeSettingsDialog(self, theme, self.current_font, self.current_font_size)
        dialog.settings_changed.connect(self.apply_theme_settings)

        # Uruchom dialog
        if dialog.exec() == QDialog.Accepted:
            # Pobierz ustawienia bezpośrednio z dialogu
            theme = dialog.get_current_theme()
            font = dialog.font_combo.currentFont().family()
            font_size = dialog.font_size_spin.value()

            # Sprawdź, czy użytkownik chce zapisać ustawienia
            save_settings = dialog.save_settings_checkbox.isChecked()

            # Zapisz ustawienia
            self.save_theme_settings(theme, font, font_size, save_settings)

    def thread_finished(self):
        """Metoda wywoływana po zakończeniu wątku"""
        print("Wątek pobierania danych zakończony.")
        # Tutaj można dodać dodatkową logikę jeśli potrzebna

    def save_theme_settings(self, theme, font_family, font_size, save_to_db):
        """Zapisuje ustawienia motywu trwale"""
        # Zaktualizuj lokalne ustawienia
        self.is_dark_theme = (theme == "dark")
        self.current_font = font_family
        self.current_font_size = font_size

        # Jeśli zaznaczono opcję zapamiętania, zapisz w bazie
        if save_to_db:
            try:
                self.settings_db.save_settings(theme, font_family, font_size)
                print(f"Ustawienia zostały zapisane do bazy danych: {theme}, {font_family}, {font_size}")
            except Exception as e:
                print(f"Błąd podczas zapisywania ustawień: {e}")

        # Zastosuj ustawienia nawet jeśli nie zapisujemy do bazy
        self.apply_theme_settings(theme, font_family, font_size)

    def apply_theme_settings(self, theme, font_family, font_size):
        """Stosuje wybrane ustawienia motywu"""
        # Zapamiętaj wybrane ustawienia
        self.is_dark_theme = (theme == "dark")
        self.current_font = font_family
        self.current_font_size = font_size

        # Zastosuj czcionkę do całej aplikacji
        font = QFont(font_family, font_size)
        QApplication.setFont(font)


        # Zastosuj motyw
        if self.is_dark_theme:
            # Ciemny motyw
            self.setStyleSheet("""
                QMainWindow, QWidget {
                    background-color: #1e1e1e;
                    color: white;
                }
                QHeaderView {
                    background-color: #2c2c2c;
                    color: white;
                }
                QHeaderView::section {
                    background-color: #2c2c2c;
                    color: white;
                    border: 1px solid #3a3a3a;
                }
                QTableWidget {
                    background-color: #2c2c2c;
                    color: white;
                    gridline-color: #3a3a3a;
                    border: 1px solid #3a3a3a;
                }
                QTableWidget::item {
                    color: white;
                }
                QTableWidget::item:selected {
                    background-color: #3498db;
                }
                QPushButton {
                    background-color: #2c2c2c;
                    color: white;
                    border: 1px solid #3a3a3a;
                    padding: 5px;
                    border-radius: 3px;
                }
                QPushButton:hover {
                    background-color: #3a3a3a;
                }
                QComboBox {
                    background-color: #2c2c2c;
                    color: white;
                    border: 1px solid #3a3a3a;
                    padding: 5px;
                    border-radius: 3px;
                }
                QComboBox::drop-down {
                    border: 0px;
                }
                QComboBox QAbstractItemView {
                    background-color: #2c2c2c;
                    color: white;
                    selection-background-color: #3498db;
                    border: 1px solid #3a3a3a;
                }
                QLabel {
                    color: white;
                }
                QDateEdit {
                    background-color: #2c2c2c;
                    color: white;
                    border: 1px solid #3a3a3a;
                    padding: 5px;
                    border-radius: 3px;
                }
                QDateEdit::drop-down {
                    border: 0px;
                    width: 20px;
                }
                QDateEdit QAbstractItemView {
                    background-color: #2c2c2c;
                    color: white;
                    selection-background-color: #3498db;
                }
                QTabWidget::pane {
                    border: 1px solid #3a3a3a;
                    background-color: #1e1e1e;
                }
                QTabBar::tab {
                    background-color: #2c2c2c;
                    color: white;
                    border: 1px solid #3a3a3a;
                    padding: 5px 10px;
                    border-top-left-radius: 4px;
                    border-top-right-radius: 4px;
                    margin-right: 2px;
                }
                QTabBar::tab:selected {
                    background-color: #3498db;
                }
                QTabBar::tab:!selected {
                    margin-top: 2px;
                }
            """)

            # Style dla komponentów filtrów
            left_panel_style = "background-color: #1e1e1e; color: white;"
            list_style = """
                QListWidget {
                    background-color: #2c2c2c;
                    color: white;
                    border: 1px solid #3a3a3a;
                    border-radius: 3px;
                }
                QListWidget::item {
                    padding: 3px;
                }
                QListWidget::item:selected {
                    background-color: #3498db;
                }
            """
            line_edit_style = """
                QLineEdit {
                    background-color: #2c2c2c;
                    color: white;
                    border: 1px solid #3a3a3a;
                    padding: 5px;
                    border-radius: 3px;
                }
            """
            date_edit_style = """
                QDateEdit {
                    background-color: #2c2c2c;
                    color: white;
                    border: 1px solid #3a3a3a;
                    padding: 5px;
                    border-radius: 3px;
                }
                QDateEdit::drop-down {
                    border: 0px;
                    width: 20px;
                }
                QDateEdit QAbstractItemView {
                    background-color: #2c2c2c;
                    color: white;
                    selection-background-color: #3498db;
                }
            """
            label_style = "color: #3498db;"
            title_style = "font-size: 16px; font-weight: bold; color: white;"

            # Styl dla przycisków
            button_style = """
                QPushButton {
                    background-color: #2c2c2c;
                    color: white;
                    border: 1px solid #3a3a3a;
                    padding: 5px;
                    border-radius: 3px;
                }
                QPushButton:hover {
                    background-color: #3a3a3a;
                }
            """

        else:
            # Jasny motyw
            self.setStyleSheet("""
                QMainWindow, QWidget {
                    background-color: #f5f5f5;
                    color: black;
                }
                QHeaderView {
                    background-color: #e0e0e0;
                    color: black;
                }
                QHeaderView::section {
                    background-color: #e0e0e0;
                    color: black;
                    border: 1px solid #cccccc;
                }
                QTableWidget {
                    background-color: white;
                    color: black;
                    gridline-color: #cccccc;
                    border: 1px solid #cccccc;
                }
                QTableWidget::item {
                    color: black;
                }
                QTableWidget::item:selected {
                    background-color: #3498db;
                    color: white;
                }
                QPushButton {
                    background-color: #e0e0e0;
                    color: black;
                    border: 1px solid #cccccc;
                    padding: 5px;
                    border-radius: 3px;
                }
                QPushButton:hover {
                    background-color: #d0d0d0;
                }
                QComboBox {
                    background-color: white;
                    color: black;
                    border: 1px solid #cccccc;
                    padding: 5px;
                    border-radius: 3px;
                }
                QComboBox::drop-down {
                    border: 0px;
                }
                QComboBox QAbstractItemView {
                    background-color: white;
                    color: black;
                    selection-background-color: #3498db;
                    selection-color: white;
                    border: 1px solid #cccccc;
                }
                QLabel {
                    color: black;
                }
                QDateEdit {
                    background-color: white;
                    color: black;
                    border: 1px solid #cccccc;
                    padding: 5px;
                    border-radius: 3px;
                }
                QDateEdit::drop-down {
                    border: 0px;
                    width: 20px;
                }
                QDateEdit QAbstractItemView {
                    background-color: white;
                    color: black;
                    selection-background-color: #3498db;
                    selection-color: white;
                }
                QTabWidget::pane {
                    border: 1px solid #cccccc;
                    background-color: #f5f5f5;
                }
                QTabBar::tab {
                    background-color: #e0e0e0;
                    color: black;
                    border: 1px solid #cccccc;
                    padding: 5px 10px;
                    border-top-left-radius: 4px;
                    border-top-right-radius: 4px;
                    margin-right: 2px;
                }
                QTabBar::tab:selected {
                    background-color: #3498db;
                    color: white;
                }
                QTabBar::tab:!selected {
                    margin-top: 2px;
                }
            """)

            # Style dla komponentów filtrów
            left_panel_style = "background-color: #f0f0f0; color: black;"
            list_style = """
                QListWidget {
                    background-color: white;
                    color: black;
                    border: 1px solid #cccccc;
                    border-radius: 3px;
                }
                QListWidget::item {
                    padding: 3px;
                }
                QListWidget::item:selected {
                    background-color: #3498db;
                    color: white;
                }
            """
            line_edit_style = """
                QLineEdit {
                    background-color: white;
                    color: black;
                    border: 1px solid #cccccc;
                    padding: 5px;
                    border-radius: 3px;
                }
            """
            date_edit_style = """
                QDateEdit {
                    background-color: white;
                    color: black;
                    border: 1px solid #cccccc;
                    padding: 5px;
                    border-radius: 3px;
                }
                QDateEdit::drop-down {
                    border: 0px;
                    width: 20px;
                }
                QDateEdit QAbstractItemView {
                    background-color: white;
                    color: black;
                    selection-background-color: #3498db;
                    selection-color: white;
                }
            """
            label_style = "color: #2980b9;"
            title_style = "font-size: 16px; font-weight: bold; color: black;"

            # Styl dla przycisków
            button_style = """
                QPushButton {
                    background-color: #e0e0e0;
                    color: black;
                    border: 1px solid #cccccc;
                    padding: 5px;
                    border-radius: 3px;
                }
                QPushButton:hover {
                    background-color: #d0d0d0;
                }
            """

            # Stylizacja comboboxa miesiąca
        if self.is_dark_theme:
            self.date_combo.setStyleSheet("""
                   QComboBox {
                       background-color: #2c2c2c;
                       color: white;
                       border: 1px solid #3a3a3a;
                       padding: 5px;
                       border-radius: 3px;
                   }
                   QComboBox::drop-down {
                       border: 0px;
                       width: 20px;
                   }
                   QComboBox QAbstractItemView {
                       background-color: #2c2c2c;
                       color: white;
                       selection-background-color: #3498db;
                       border: 1px solid #3a3a3a;
                   }
               """)
        else:
            self.date_combo.setStyleSheet("""
                   QComboBox {
                       background-color: white;
                       color: black;
                       border: 1px solid #cccccc;
                       padding: 5px;
                       border-radius: 3px;
                   }
                   QComboBox::drop-down {
                       border: 0px;
                       width: 20px;
                   }
                   QComboBox QAbstractItemView {
                       background-color: white;
                       color: black;
                       selection-background-color: #3498db;
                       selection-color: white;
                       border: 1px solid #cccccc;
                   }
               """)

        # Stylizacja numerów wierszy
        if self.is_dark_theme:
            self.table.verticalHeader().setStyleSheet("""
                QHeaderView::section {
                    background-color: #2c2c2c;
                    color: white;
                    border: 1px solid #3a3a3a;
                    padding: 3px;
                }
            """)
            self.events_table.verticalHeader().setStyleSheet("""
                QHeaderView::section {
                    background-color: #2c2c2c;
                    color: white;
                    border: 1px solid #3a3a3a;
                    padding: 3px;
                }
            """)
        else:
            self.table.verticalHeader().setStyleSheet("""
                QHeaderView::section {
                    background-color: #e0e0e0;
                    color: black;
                    border: 1px solid #cccccc;
                    padding: 3px;
                }
            """)
            self.events_table.verticalHeader().setStyleSheet("""
                QHeaderView::section {
                    background-color: #e0e0e0;
                    color: black;
                    border: 1px solid #cccccc;
                    padding: 3px;
                }
            """)

        # Zastosowanie stylów do wszystkich komponentów
        self._left_panel.setStyleSheet(left_panel_style)

        # Aktualizacja stylów dla list i pól wyszukiwania
        self.wydzial_list.setStyleSheet(list_style)
        self.przelozony_list.setStyleSheet(list_style)
        self.uzytkownik_list.setStyleSheet(list_style)

        self.wydzial_filter.setStyleSheet(line_edit_style)
        self.przelozony_filter.setStyleSheet(line_edit_style)
        self.uzytkownik_filter.setStyleSheet(line_edit_style)

        # Zastosuj styl do przycisków
        self.theme_button.setStyleSheet(button_style)
        self.refresh_button.setStyleSheet(button_style)
        self.clear_filters_button.setStyleSheet(button_style)
        self.insert_symbol_button.setStyleSheet(button_style)


        # Zastosuj styl do filtrów zdarzeń
        if hasattr(self, 'date_from'):
            self.date_from.setStyleSheet(date_edit_style)
            self.date_to.setStyleSheet(date_edit_style)
            self.topic_filter.setStyleSheet(line_edit_style)
            self.name_filter.setStyleSheet(line_edit_style)
            self.filter_button.setStyleSheet(button_style)

        # # Aktualizacja stylu separatora
        # if hasattr(self, 'separator_top'):
        #     self.separator_top.setStyleSheet(
        #         "background-color: #3a3a3a;" if self.is_dark_theme else "background-color: #cccccc;")

        # Zastosuj czcionkę i rozmiar do etykiet
        for widget in self.findChildren(QLabel):
            widget.setFont(font)

        # Etykiety w panelu filtrów
        for label in self.findChildren(QLabel):
            if label.text() in ["Wydział:", "Przełożony:", "Użytkownik:"]:
                label.setStyleSheet(label_style)
            elif label.text() == "Filtry":
                label.setStyleSheet(title_style)

        # Aktualizacja czcionki w tabeli
        self.table.setFont(font)
        self.date_combo.setFont(font)

        # Aktualizacja czcionki w nagłówkach tabeli
        header_font = QFont(font_family, font_size)
        self.table.horizontalHeader().setFont(header_font)
        self.table.verticalHeader().setFont(header_font)

        # Dodatkowo aktualizuj styl dla tabeli zdarzeń
        if hasattr(self, 'events_table'):
            self.events_table.setStyleSheet(
                """
                QTableWidget {
                    background-color: #2c2c2c;
                    color: white;
                    gridline-color: #3a3a3a;
                    border: 1px solid #3a3a3a;
                }
                QTableWidget::item {
                    color: white;
                }
                QTableWidget::item:selected {
                    background-color: #3498db;
                }
                """
                if self.is_dark_theme else
                """
                QTableWidget {
                    background-color: white;
                    color: black;
                    gridline-color: #cccccc;
                    border: 1px solid #cccccc;
                }
                QTableWidget::item {
                    color: black;
                }
                QTableWidget::item:selected {
                    background-color: #3498db;
                    color: white;
                }
                """
            )

            # Aktualizacja czcionki w tabeli zdarzeń
            self.events_table.setFont(font)
            self.events_table.horizontalHeader().setFont(header_font)

        # Aktualizacja kolorów weekendów w nagłówku
        header = self.table.horizontalHeader()
        if isinstance(header, WeekendAwareHeaderView):
            header.dark_theme = self.is_dark_theme

            # Pobierz aktualny rok i miesiąc
            current_data = self.date_combo.currentData()
            if current_data:
                year, month_idx = current_data

                # Określ liczbę dni w miesiącu i znajdź weekendy
                days_in_month = 31  # domyślna wartość
                if month_idx in [4, 6, 9, 11]:
                    days_in_month = 30
                elif month_idx == 2:
                    if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0):
                        days_in_month = 29
                    else:
                        days_in_month = 28

                weekend_columns = []
                # Aktualizuj kolory weekendów
                for col in range(3, 3 + days_in_month):
                    day = col - 2
                    date = QDate(year, month_idx, day)
                    day_of_week = date.dayOfWeek()

                    if day_of_week >= 6:  # weekend
                        weekend_columns.append(col)
                        header_item = self.table.horizontalHeaderItem(col)
                        if header_item:
                            if self.is_dark_theme:
                                header_item.setForeground(QColor(255, 99, 71))  # Tomato red dla ciemnego motywu
                            else:
                                header_item.setForeground(QColor(220, 20, 60))  # Crimson dla jasnego motywu

                # Aktualizuj kolumny weekendowe
                header.set_weekend_columns(weekend_columns, self.is_dark_theme)

            # Wymuś odświeżenie widoku nagłówka
            header.viewport().update()


if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = WorkScheduleWindow()
    window.show()
    sys.exit(app.exec())
